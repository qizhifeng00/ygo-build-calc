{"version":3,"sources":["../src/utils.ts","../src/condition.ts","../src/calculator.ts","../src/optimizer.ts","../src/worker.ts"],"names":["items","first"],"mappings":";;;AAWO,SAAS,WAAW,OAAA,EAAyB;AAClD,EAAA,MAAM,EAAA,GAAK,QAAQ,WAAA,EAAY;AAG/B,EAAA,IAAI,EAAA,CAAG,WAAW,CAAA,EAAG;AACnB,IAAA,MAAM,IAAA,GAAO,EAAA,CAAG,UAAA,CAAW,CAAC,CAAA,GAAI,EAAA;AAChC,IAAA,IAAI,IAAA,IAAQ,CAAA,IAAK,IAAA,GAAO,EAAA,EAAI,OAAO,IAAA;AAAA,EACrC;AAGA,EAAA,IAAI,GAAG,MAAA,KAAW,CAAA,IAAK,EAAA,CAAG,CAAC,MAAM,GAAA,EAAK;AACpC,IAAA,MAAM,IAAA,GAAO,EAAA,CAAG,UAAA,CAAW,CAAC,CAAA,GAAI,EAAA;AAChC,IAAA,IAAI,IAAA,IAAQ,CAAA,IAAK,IAAA,GAAO,CAAA,SAAU,EAAA,GAAK,IAAA;AAAA,EACzC;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sCAAA,EAAW,OAAO,CAAA,CAAE,CAAA;AACtC;AASO,SAAS,WAAW,KAAA,EAAuB;AAChD,EAAA,IAAI,KAAA,GAAQ,CAAA,IAAK,KAAA,IAAS,EAAA,EAAI;AAC5B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sCAAA,EAAW,KAAK,CAAA,CAAE,CAAA;AAAA,EACpC;AAEA,EAAA,IAAI,QAAQ,EAAA,EAAI;AACd,IAAA,OAAO,MAAA,CAAO,YAAA,CAAa,EAAA,GAAK,KAAK,CAAA;AAAA,EACvC;AAEA,EAAA,OAAO,GAAA,GAAM,MAAA,CAAO,YAAA,CAAa,EAAA,GAAK,QAAQ,EAAE,CAAA;AAClD;AASO,SAAS,aAAa,KAAA,EAAuB;AAClD,EAAA,IAAI,KAAA,GAAQ,CAAA,IAAK,KAAA,IAAS,EAAA,EAAI;AAC5B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sCAAA,EAAW,KAAK,CAAA,CAAE,CAAA;AAAA,EACpC;AAEA,EAAA,IAAI,QAAQ,EAAA,EAAI;AACd,IAAA,OAAO,MAAA,CAAO,YAAA,CAAa,EAAA,GAAK,KAAK,CAAA;AAAA,EACvC;AAEA,EAAA,OAAO,GAAA,GAAM,MAAA,CAAO,YAAA,CAAa,EAAA,GAAK,QAAQ,EAAE,CAAA;AAClD;AAKA,IAAM,gBAAA,uBAAuB,GAAA,EAAoB;AAK1C,SAAS,WAAA,CAAY,GAAoB,CAAA,EAA4B;AAC1E,EAAA,MAAM,IAAA,GAAO,OAAO,CAAC,CAAA;AACrB,EAAA,MAAM,IAAA,GAAO,OAAO,CAAC,CAAA;AAErB,EAAA,IAAI,IAAA,GAAO,EAAA,IAAM,IAAA,GAAO,IAAA,EAAM,OAAO,EAAA;AACrC,EAAA,IAAI,IAAA,KAAS,EAAA,IAAM,IAAA,KAAS,IAAA,EAAM,OAAO,EAAA;AAEzC,EAAA,MAAM,GAAA,GAAM,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA;AAC3B,EAAA,IAAI,gBAAA,CAAiB,GAAA,CAAI,GAAG,CAAA,EAAG;AAC7B,IAAA,OAAO,gBAAA,CAAiB,IAAI,GAAG,CAAA;AAAA,EACjC;AAEA,EAAA,IAAI,MAAA,GAAS,EAAA;AACb,EAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,IAAA,EAAM,CAAA,EAAA,EAAK;AAC/B,IAAA,MAAA,GAAS,MAAA,IAAU,IAAA,GAAO,IAAA,GAAO,CAAA,CAAA,GAAK,CAAA;AAAA,EACxC;AAEA,EAAA,gBAAA,CAAiB,GAAA,CAAI,KAAK,MAAM,CAAA;AAChC,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,qBAAA,GAA8B;AAC5C,EAAA,gBAAA,CAAiB,KAAA,EAAM;AACzB;AAKO,SAAS,aAAgB,KAAA,EAAiB;AAC/C,EAAA,MAAM,MAAA,GAAS,CAAC,GAAG,KAAK,CAAA;AACxB,EAAA,KAAA,IAAS,IAAI,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,CAAA,GAAI,GAAG,CAAA,EAAA,EAAK;AAC1C,IAAA,MAAM,IAAI,IAAA,CAAK,KAAA,CAAM,KAAK,MAAA,EAAO,IAAK,IAAI,CAAA,CAAE,CAAA;AAC5C,IAAA,MAAM,IAAA,GAAO,OAAO,CAAC,CAAA;AACrB,IAAA,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA;AACpB,IAAA,MAAA,CAAO,CAAC,CAAA,GAAI,IAAA;AAAA,EACd;AACA,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,SAAA,CAAU,IAAA,EAAgB,KAAA,EAAe,aAAA,EAAiC;AACxF,EAAA,MAAM,MAAA,GAAS,KAAA,CAAM,aAAa,CAAA,CAAE,KAAK,CAAC,CAAA;AAC1C,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,KAAK,CAAA;AACjC,EAAA,KAAA,CAAM,QAAQ,CAAA,GAAA,KAAO;AACnB,IAAA,MAAA,CAAO,GAAG,CAAA,EAAA;AAAA,EACZ,CAAC,CAAA;AACD,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,WAAW,UAAA,EAAgC;AACzD,EAAA,MAAM,OAAiB,EAAC;AACxB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,CAAW,QAAQ,CAAA,EAAA,EAAK;AAC1C,IAAA,MAAM,KAAA,GAAQ,WAAW,CAAC,CAAA;AAC1B,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,EAAO,CAAA,EAAA,EAAK;AAC9B,QAAA,IAAA,CAAK,KAAK,CAAC,CAAA;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACA,EAAA,OAAO,IAAA;AACT;AAKO,SAAS,aAAa,GAAA,EAAqB;AAChD,EAAA,OAAO,GAAA,CAAI,OAAA,CAAQ,qBAAA,EAAuB,MAAM,CAAA;AAClD;;;ACtIA,IAAM,YAAA,GAA2E;AAAA,EAC/E,GAAA,EAAK,IAAA;AAAA,EACL,GAAA,EAAK,IAAA;AAAA,EACL,IAAA,EAAM,IAAA;AAAA,EACN,IAAA,EAAM,KAAA;AAAA,EACN,IAAA,EAAM,KAAA;AAAA,EACN,IAAA,EAAM;AACR,CAAA;AAEA,IAAM,gBAAA,GAA2C;AAAA,EAC/C,IAAA,EAAM,GAAA;AAAA,EACN,IAAA,EAAM,GAAA;AAAA,EACN,IAAA,EAAM,IAAA;AAAA,EACN,KAAA,EAAO,IAAA;AAAA,EACP,KAAA,EAAO,IAAA;AAAA,EACP,KAAA,EAAO;AACT,CAAA;AAKA,IAAM,SAAN,MAAa;AAAA,EACH,MAAA;AAAA,EACA,GAAA,GAAc,CAAA;AAAA,EAEtB,YAAY,MAAA,EAAkB;AAC5B,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AAAA,EAChB;AAAA,EAEA,IAAA,GAA2B;AACzB,IAAA,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA;AAAA,EAC7B;AAAA,EAEA,QAAQ,QAAA,EAA2B;AACjC,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA;AAClC,IAAA,IAAI,QAAA,IAAY,UAAU,QAAA,EAAU;AAClC,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,aAAA,EAAM,QAAQ,CAAA,yBAAA,EAAQ,KAAA,IAAS,cAAI,CAAA,CAAE,CAAA;AAAA,IACvD;AACA,IAAA,IAAI,CAAC,KAAA,EAAO;AACV,MAAA,MAAM,IAAI,MAAM,gCAAO,CAAA;AAAA,IACzB;AACA,IAAA,IAAA,CAAK,GAAA,EAAA;AACL,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,GAAA,GAAe;AACb,IAAA,OAAO,IAAA,CAAK,GAAA,IAAO,IAAA,CAAK,MAAA,CAAO,MAAA;AAAA,EACjC;AAAA,EAEA,SAAA,GAAoB;AAClB,IAAA,OAAO,KAAK,MAAA,CAAO,KAAA,CAAM,KAAK,GAAG,CAAA,CAAE,KAAK,GAAG,CAAA;AAAA,EAC7C;AAAA,EAEA,MAAA,GAAiB;AACf,IAAA,OAAO,IAAA,CAAK,GAAA;AAAA,EACd;AAAA,EAEA,OAAO,GAAA,EAAmB;AACxB,IAAA,IAAA,CAAK,GAAA,GAAM,GAAA;AAAA,EACb;AACF,CAAA;AAKA,SAAS,SAAS,IAAA,EAAwB;AAIxC,EAAA,MAAM,KAAA,GAAQ,oEAAA;AACd,EAAA,MAAM,SAAmB,EAAC;AAC1B,EAAA,IAAI,CAAA;AACJ,EAAA,IAAI,SAAA,GAAY,CAAA;AAEhB,EAAA,OAAA,CAAQ,CAAA,GAAI,KAAA,CAAM,IAAA,CAAK,IAAI,OAAO,IAAA,EAAM;AAEtC,IAAA,IAAI,CAAA,CAAE,QAAQ,SAAA,EAAW;AACvB,MAAA,MAAM,UAAU,IAAA,CAAK,SAAA,CAAU,WAAW,CAAA,CAAE,KAAK,EAAE,IAAA,EAAK;AACxD,MAAA,IAAI,OAAA,EAAS;AACX,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,uCAAA,EAAY,OAAO,CAAA,CAAA,CAAG,CAAA;AAAA,MACxC;AAAA,IACF;AACA,IAAA,MAAM,KAAA,GAAQ,EAAE,CAAC,CAAA;AACjB,IAAA,IAAI,KAAA,EAAO,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA;AAC5B,IAAA,SAAA,GAAY,KAAA,CAAM,SAAA;AAAA,EACpB;AAGA,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,SAAA,CAAU,SAAS,EAAE,IAAA,EAAK;AACjD,EAAA,IAAI,SAAA,EAAW;AACb,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,uCAAA,EAAY,SAAS,CAAA,CAAA,CAAG,CAAA;AAAA,EAC1C;AAEA,EAAA,OAAO,MAAA;AACT;AAKA,SAAS,gBAAgB,MAAA,EAA+B;AACtD,EAAA,OAAO,eAAe,MAAM,CAAA;AAC9B;AAKA,SAAS,eAAe,MAAA,EAA+B;AACrD,EAAA,IAAI,IAAA,GAAO,gBAAgB,MAAM,CAAA;AAEjC,EAAA,OAAO,CAAC,MAAA,CAAO,GAAA,EAAI,EAAG;AACpB,IAAA,MAAM,IAAA,GAAO,OAAO,IAAA,EAAK;AACzB,IAAA,IAAI,SAAS,IAAA,EAAM;AACnB,IAAA,MAAA,CAAO,QAAQ,IAAI,CAAA;AACnB,IAAA,MAAM,KAAA,GAAQ,gBAAgB,MAAM,CAAA;AACpC,IAAA,IAAA,GAAO,EAAE,IAAA,EAAM,IAAA,EAAM,UAAU,CAAC,IAAA,EAAM,KAAK,CAAA,EAAE;AAAA,EAC/C;AAEA,EAAA,OAAO,IAAA;AACT;AAKA,SAAS,gBAAgB,MAAA,EAA+B;AACtD,EAAA,IAAI,IAAA,GAAO,gBAAgB,MAAM,CAAA;AAEjC,EAAA,OAAO,CAAC,MAAA,CAAO,GAAA,EAAI,EAAG;AACpB,IAAA,MAAM,IAAA,GAAO,OAAO,IAAA,EAAK;AACzB,IAAA,IAAI,SAAS,IAAA,EAAM;AACnB,IAAA,MAAA,CAAO,QAAQ,IAAI,CAAA;AACnB,IAAA,MAAM,KAAA,GAAQ,gBAAgB,MAAM,CAAA;AACpC,IAAA,IAAA,GAAO,EAAE,IAAA,EAAM,KAAA,EAAO,UAAU,CAAC,IAAA,EAAM,KAAK,CAAA,EAAE;AAAA,EAChD;AAEA,EAAA,OAAO,IAAA;AACT;AAKA,SAAS,gBAAgB,MAAA,EAA+B;AACtD,EAAA,MAAM,IAAA,GAAO,SAAS,MAAM,CAAA;AAG5B,EAAA,IAAI,OAAO,SAAS,QAAA,IAAY,CAAC,MAAM,OAAA,CAAQ,IAAI,CAAA,IAAK,MAAA,IAAU,IAAA,EAAM;AACtE,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,MAAM,IAAA,GAAO,OAAO,IAAA,EAAK;AACzB,EAAA,IAAI,CAAC,OAAO,GAAA,EAAI,IAAK,QAAQ,qBAAA,CAAsB,IAAA,CAAK,IAAI,CAAA,EAAG;AAC7D,IAAA,MAAM,EAAA,GAAK,OAAO,OAAA,EAAQ;AAC1B,IAAA,MAAM,GAAA,GAAM,OAAO,OAAA,EAAQ;AAE3B,IAAA,IAAI,CAAC,OAAA,CAAQ,IAAA,CAAK,GAAG,CAAA,EAAG;AACtB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iDAAA,EAAY,GAAA,IAAO,cAAI,CAAA,CAAE,CAAA;AAAA,IAC3C;AAEA,IAAA,MAAM,QAAsC,EAAC;AAE7C,IAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,IAAI,CAAA,EAAG;AACvB,MAAA,MAAM,KAAA,GAAQ,KAAK,CAAC,CAAA;AACpB,MAAA,IAAI,CAAC,KAAA,EAAO,MAAM,IAAI,MAAM,gCAAO,CAAA;AACnC,MAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,KAAA,EAAO,CAAA;AAC1B,MAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA,EAAG;AACvC,QAAA,MAAM,QAAA,GAAW,KAAK,CAAC,CAAA;AACvB,QAAA,MAAM,OAAA,GAAU,IAAA,CAAK,CAAA,GAAI,CAAC,CAAA;AAC1B,QAAA,IAAI,CAAC,OAAA,EAAS,MAAM,IAAI,MAAM,sCAAQ,CAAA;AACtC,QAAA,KAAA,CAAM,IAAA,CAAK,EAAE,QAAA,EAAU,IAAA,EAAM,SAAS,CAAA;AAAA,MACxC;AAAA,IACF,CAAA,MAAA,IAAW,OAAO,IAAA,KAAS,QAAA,EAAU;AACnC,MAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,IAAA,EAAM,CAAA;AAAA,IAC3B,CAAA,MAAO;AACL,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,wDAAA,EAAc,KAAK,SAAA,CAAU,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,IACtD;AAEA,IAAA,MAAM,MAAA,GAAS,aAAa,EAAE,CAAA;AAC9B,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4CAAA,EAAY,EAAE,CAAA,CAAE,CAAA;AAAA,IAClC;AAEA,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,QAAA;AAAA,MACN,KAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACF;AAAA,EACF;AAGA,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sCAAA,EAAW,KAAK,SAAA,CAAU,IAAI,CAAC,CAAA,CAAE,CAAA;AACnD;AAKA,SAAS,SAAS,MAAA,EAAmD;AACnE,EAAA,IAAI,MAAA,CAAO,IAAA,EAAK,KAAM,GAAA,EAAK;AACzB,IAAA,MAAA,CAAO,QAAQ,GAAG,CAAA;AAGlB,IAAA,MAAM,QAAA,GAAW,OAAO,MAAA,EAAO;AAC/B,IAAA,IAAI;AACF,MAAA,MAAM,IAAA,GAAO,gBAAgB,MAAM,CAAA;AACnC,MAAA,IAAI,MAAA,CAAO,IAAA,EAAK,KAAM,GAAA,EAAK;AACzB,QAAA,MAAA,CAAO,QAAQ,GAAG,CAAA;AAClB,QAAA,OAAO,IAAA;AAAA,MACT;AAAA,IACF,SAAS,CAAA,EAAG;AAEV,MAAA,MAAA,CAAO,OAAO,QAAQ,CAAA;AAAA,IACxB;AAGA,IAAA,MAAA,CAAO,OAAO,QAAQ,CAAA;AACtB,IAAA,MAAMA,SAAkB,EAAC;AACzB,IAAAA,MAAAA,CAAM,IAAA,CAAK,MAAA,CAAO,OAAA,EAAS,CAAA;AAE3B,IAAA,OAAO,CAAC,MAAA,CAAO,GAAA,EAAI,EAAG;AACpB,MAAA,MAAM,IAAA,GAAO,OAAO,IAAA,EAAK;AACzB,MAAA,IAAI,CAAC,IAAA,IAAQ,CAAC,CAAC,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAG,CAAA,CAAE,QAAA,CAAS,IAAI,CAAA,EAAG;AACnD,MAAA,MAAM,QAAA,GAAW,OAAO,OAAA,EAAQ;AAChC,MAAAA,MAAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,MAAA,MAAM,OAAA,GAAU,OAAO,OAAA,EAAQ;AAC/B,MAAAA,MAAAA,CAAM,KAAK,OAAO,CAAA;AAAA,IACpB;AAEA,IAAA,MAAA,CAAO,QAAQ,GAAG,CAAA;AAClB,IAAA,MAAMC,MAAAA,GAAQD,OAAM,CAAC,CAAA;AACrB,IAAA,OAAOA,MAAAA,CAAM,MAAA,KAAW,CAAA,IAAKC,MAAAA,GAAQA,MAAAA,GAAQD,MAAAA;AAAA,EAC/C;AAGA,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,KAAA,GAAQ,OAAO,OAAA,EAAQ;AAC7B,EAAA,KAAA,CAAM,KAAK,KAAK,CAAA;AAEhB,EAAA,OAAO,CAAC,MAAA,CAAO,GAAA,EAAI,EAAG;AACpB,IAAA,MAAM,IAAA,GAAO,OAAO,IAAA,EAAK;AACzB,IAAA,IAAI,CAAC,IAAA,IAAQ,CAAC,CAAC,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAG,CAAA,CAAE,QAAA,CAAS,IAAI,CAAA,EAAG;AACnD,IAAA,MAAM,QAAA,GAAW,OAAO,OAAA,EAAQ;AAChC,IAAA,KAAA,CAAM,KAAK,QAAQ,CAAA;AACnB,IAAA,MAAM,OAAA,GAAU,OAAO,OAAA,EAAQ;AAC/B,IAAA,KAAA,CAAM,KAAK,OAAO,CAAA;AAAA,EACpB;AAEA,EAAA,MAAM,SAAA,GAAY,MAAM,CAAC,CAAA;AACzB,EAAA,OAAO,KAAA,CAAM,MAAA,KAAW,CAAA,IAAK,SAAA,GAAY,SAAA,GAAY,KAAA;AACvD;AAKA,SAAS,iBAAiB,SAAA,EAAyC;AACjE,EAAA,IAAI,SAAA,CAAU,SAAS,QAAA,EAAU;AAC/B,IAAA,OAAO,SAAA;AAAA,EACT;AAEA,EAAA,MAAM,eAAgC,EAAC;AACvC,EAAA,KAAA,MAAW,KAAA,IAAS,UAAU,QAAA,EAAU;AACtC,IAAA,MAAM,SAAA,GAAY,iBAAiB,KAAK,CAAA;AAExC,IAAA,IAAI,SAAA,CAAU,IAAA,KAAS,SAAA,CAAU,IAAA,EAAM;AACrC,MAAA,YAAA,CAAa,IAAA,CAAK,GAAI,SAAA,CAAmC,QAAQ,CAAA;AAAA,IACnE,CAAA,MAAO;AACL,MAAA,YAAA,CAAa,KAAK,SAAS,CAAA;AAAA,IAC7B;AAAA,EACF;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,SAAA,CAAU,IAAA,EAAM,UAAU,YAAA,EAAa;AACxD;AAOO,SAAS,eAAe,IAAA,EAA6B;AAC1D,EAAA,MAAM,OAAA,GAAU,KAAK,IAAA,EAAK;AAC1B,EAAA,IAAI,CAAC,OAAA,EAAS;AACZ,IAAA,MAAM,IAAI,MAAM,4CAAS,CAAA;AAAA,EAC3B;AAEA,EAAA,MAAM,MAAA,GAAS,SAAS,OAAO,CAAA;AAC/B,EAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG;AACvB,IAAA,MAAM,IAAI,MAAM,0EAAc,CAAA;AAAA,EAChC;AAEA,EAAA,MAAM,MAAA,GAAS,IAAI,MAAA,CAAO,MAAM,CAAA;AAChC,EAAA,MAAM,IAAA,GAAO,gBAAgB,MAAM,CAAA;AAEnC,EAAA,IAAI,CAAC,MAAA,CAAO,GAAA,EAAI,EAAG;AACjB,IAAA,MAAM,IAAI,MAAM,CAAA,0CAAA,EAAU,OAAO,uBAAQ,MAAA,CAAO,SAAA,EAAW,CAAA,MAAA,CAAG,CAAA;AAAA,EAChE;AAGA,EAAA,IAAI,IAAA,CAAK,SAAS,QAAA,EAAU;AAC1B,IAAA,OAAO,EAAE,IAAA,EAAM,KAAA,EAAO,QAAA,EAAU,CAAC,IAAI,CAAA,EAAE;AAAA,EACzC;AAGA,EAAA,OAAO,iBAAiB,IAAI,CAAA;AAC9B;AAKO,SAAS,kBAAkB,SAAA,EAAkC;AAClE,EAAA,IAAI,SAAA,CAAU,SAAS,QAAA,EAAU;AAC/B,IAAA,MAAM,SAAA,GAAY,UAAU,KAAA,CACzB,GAAA,CAAI,CAAC,CAAA,EAAG,CAAA,KAAM,MAAM,CAAA,GAAI,CAAA,CAAE,OAAO,CAAA,EAAG,CAAA,CAAE,YAAY,GAAG,CAAA,CAAA,EAAI,EAAE,IAAI,CAAA,CAAE,CAAA,CACjE,IAAA,CAAK,GAAG,CAAA;AACX,IAAA,MAAM,QAAA,GAAW,gBAAA,CAAiB,SAAA,CAAU,MAAM,KAAK,SAAA,CAAU,MAAA;AACjE,IAAA,OAAO,IAAI,SAAS,CAAA,EAAA,EAAK,QAAQ,CAAA,CAAA,EAAI,UAAU,GAAG,CAAA,CAAA;AAAA,EACpD;AAEA,EAAA,MAAM,eAAe,SAAA,CAAU,QAAA,CAC5B,IAAI,iBAAiB,CAAA,CACrB,OAAO,OAAO,CAAA;AAEjB,EAAA,OAAO,YAAA,CAAa,MAAA,GAAS,CAAA,GACzB,CAAA,CAAA,EAAI,aAAa,IAAA,CAAK,SAAA,CAAU,IAAA,KAAS,KAAA,GAAQ,SAAS,MAAM,CAAC,CAAA,CAAA,CAAA,GACjE,YAAA,CAAa,CAAC,CAAA,IAAK,EAAA;AACzB;AAKO,SAAS,iBAAiB,SAAA,EAA6C;AAC5E,EAAA,IAAI,SAAA,CAAU,SAAS,QAAA,EAAU;AAE/B,IAAA,IAAI,IAAA,GAAO,EAAA;AACX,IAAA,SAAA,CAAU,KAAA,CAAM,OAAA,CAAQ,CAAC,IAAA,EAAM,CAAA,KAAM;AACnC,MAAA,IAAI,MAAM,CAAA,EAAG;AACX,QAAA,IAAA,IAAQ,CAAA,OAAA,EAAU,UAAA,CAAW,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAA;AAAA,MACzC,CAAA,MAAO;AACL,QAAA,IAAA,IAAQ,CAAA,CAAA,EAAI,KAAK,QAAA,IAAY,GAAG,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAA;AAAA,MAClE;AAAA,IACF,CAAC,CAAA;AAED,IAAA,MAAM,EAAA,GAAK,gBAAA,CAAiB,SAAA,CAAU,MAAM,CAAA;AAC5C,IAAA,IAAI,CAAC,EAAA,EAAI;AACP,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4CAAA,EAAY,SAAA,CAAU,MAAM,CAAA,CAAE,CAAA;AAAA,IAChD;AACA,IAAA,IAAA,GAAO,IAAI,IAAI,CAAA,EAAA,EAAK,EAAE,CAAA,CAAA,EAAI,UAAU,GAAG,CAAA,CAAA;AAEvC,IAAA,OAAO,IAAI,QAAA,CAAS,QAAA,EAAU,CAAA,OAAA,EAAU,IAAI,CAAA,CAAE,CAAA;AAAA,EAChD;AAGA,EAAA,MAAM,UAAA,GAAa,SAAA,CAAU,QAAA,CAAS,GAAA,CAAI,gBAAgB,CAAA;AAE1D,EAAA,IAAI,SAAA,CAAU,SAAS,KAAA,EAAO;AAC5B,IAAA,OAAO,CAAC,MAAA,KAAqB,UAAA,CAAW,MAAM,CAAA,EAAA,KAAM,EAAA,CAAG,MAAM,CAAC,CAAA;AAAA,EAChE,CAAA,MAAO;AACL,IAAA,OAAO,CAAC,MAAA,KAAqB,UAAA,CAAW,KAAK,CAAA,EAAA,KAAM,EAAA,CAAG,MAAM,CAAC,CAAA;AAAA,EAC/D;AACF;AAKO,SAAS,uBAAuB,IAAA,EAAiC;AACtE,EAAA,MAAM,SAAA,GAAY,eAAe,IAAI,CAAA;AACrC,EAAA,OAAO,iBAAiB,SAAS,CAAA;AACnC;AAKO,SAAS,wBAAwB,IAAA,EAAwB;AAC9D,EAAA,MAAM,QAAA,GAAW,cAAA;AACjB,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAAY;AAClC,EAAA,IAAI,KAAA;AAEJ,EAAA,OAAA,CAAQ,KAAA,GAAQ,QAAA,CAAS,IAAA,CAAK,IAAI,OAAO,IAAA,EAAM;AAC7C,IAAA,IAAI;AACF,MAAA,MAAM,OAAA,GAAU,MAAM,CAAC,CAAA;AACvB,MAAA,IAAI,OAAA,EAAS;AACX,QAAA,MAAM,GAAA,GAAM,WAAW,OAAO,CAAA;AAC9B,QAAA,SAAA,CAAU,IAAI,GAAG,CAAA;AAAA,MACnB;AAAA,IACF,CAAA,CAAA,MAAQ;AAAA,IAER;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,SAAS,CAAA,CAAE,KAAK,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,GAAI,CAAC,CAAA;AACnD;AAOO,SAAS,gBAAA,CAAiB,MAAc,OAAA,EAA8B;AAC3E,EAAA,IAAI,MAAA,GAAS,IAAA;AAGb,EAAA,MAAM,WAAA,GAAc,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA,CAAE,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,CAAE,MAAA,GAAS,CAAA,CAAE,MAAM,CAAA;AAE3E,EAAA,KAAA,MAAW,QAAQ,WAAA,EAAa;AAC9B,IAAA,MAAM,WAAA,GAAc,QAAQ,IAAI,CAAA;AAChC,IAAA,IAAI,CAAC,WAAA,EAAa;AAClB,IAAA,MAAM,QAAQ,IAAI,MAAA,CAAO,YAAA,CAAa,IAAI,GAAG,GAAG,CAAA;AAChD,IAAA,MAAA,GAAS,MAAA,CAAO,OAAA,CAAQ,KAAA,EAAO,WAAW,CAAA;AAAA,EAC5C;AAEA,EAAA,OAAO,MAAA;AACT;;;ACzZO,SAAS,cAAA,CACd,UAAA,EACA,KAAA,EACA,SAAA,EACA,UAAA,EACmB;AACnB,EAAA,MAAM,UAAA,GAAa,WAAW,MAAA,CAAO,CAAC,GAAG,CAAA,KAAM,CAAA,GAAI,GAAG,CAAC,CAAA;AAEvD,EAAA,IAAI,eAAe,CAAA,EAAG;AACpB,IAAA,MAAM,IAAI,MAAM,0BAAM,CAAA;AAAA,EACxB;AAEA,EAAA,IAAI,QAAQ,UAAA,EAAY;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAAQ,KAAK,CAAA,kDAAA,EAAa,UAAU,CAAA,CAAA,CAAG,CAAA;AAAA,EACzD;AAGA,EAAA,MAAM,aAAA,GAAgB,uBAAuB,SAAS,CAAA;AAEtD,EAAA,IAAI,KAAA,GAAQ,EAAA;AACZ,EAAA,IAAI,KAAA,GAAQ,EAAA;AACZ,EAAA,IAAI,oBAAA,GAAuB,CAAA;AAG3B,EAAA,SAAS,OAAA,CAAQ,KAAA,EAAe,MAAA,EAAkB,SAAA,EAAmB;AACnE,IAAA,IAAI,KAAA,KAAU,WAAW,MAAA,EAAQ;AAC/B,MAAA,IAAI,cAAc,CAAA,EAAG;AAGrB,MAAA,IAAI,IAAA,GAAO,EAAA;AACX,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,QAAA,MAAM,SAAA,GAAY,WAAW,CAAC,CAAA;AAC9B,QAAA,MAAM,SAAA,GAAY,OAAO,CAAC,CAAA;AAC1B,QAAA,IAAI,SAAA,KAAc,MAAA,IAAa,SAAA,KAAc,MAAA,EAAW;AACxD,QAAA,IAAA,IAAQ,WAAA,CAAY,WAAW,SAAS,CAAA;AAAA,MAC1C;AAEA,MAAA,KAAA,IAAS,IAAA;AACT,MAAA,IAAI,aAAA,CAAc,MAAM,CAAA,EAAG;AACzB,QAAA,KAAA,IAAS,IAAA;AAAA,MACX;AACA,MAAA;AAAA,IACF;AAGA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,IAAA,CAAK,MAAO,KAAA,GAAQ,UAAA,CAAW,MAAA,GAAU,GAAG,CAAC,CAAA;AAC5E,IAAA,IAAI,QAAA,GAAW,wBAAwB,UAAA,EAAY;AACjD,MAAA,oBAAA,GAAuB,QAAA;AACvB,MAAA,UAAA,CAAW,QAAA,EAAU,CAAA,gCAAA,EAAU,QAAQ,CAAA,CAAA,CAAG,CAAA;AAAA,IAC5C;AAGA,IAAA,MAAM,YAAA,GAAe,WAAW,KAAK,CAAA;AACrC,IAAA,IAAI,iBAAiB,MAAA,EAAW;AAEhC,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,GAAA,CAAI,YAAA,EAAc,SAAS,CAAA;AAC5C,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,IAAK,GAAA,EAAK,CAAA,EAAA,EAAK;AAC7B,MAAA,MAAA,CAAO,KAAK,CAAA,GAAI,CAAA;AAChB,MAAA,OAAA,CAAQ,QAAQ,CAAA,EAAG,CAAC,GAAG,MAAM,CAAA,EAAG,YAAY,CAAC,CAAA;AAAA,IAC/C;AAAA,EACF;AAEA,EAAA,OAAA,CAAQ,CAAA,EAAG,EAAC,EAAG,KAAK,CAAA;AAEpB,EAAA,IAAI,UAAA,EAAY;AACd,IAAA,UAAA,CAAW,KAAK,sCAAQ,CAAA;AAAA,EAC1B;AAEA,EAAA,OAAO;AAAA,IACL,KAAA;AAAA,IACA,KAAA;AAAA,IACA,WAAA,EAAa,MAAA,CAAQ,KAAA,GAAQ,MAAA,GAAU,KAAK,CAAA,GAAI,GAAA;AAAA,IAChD,iBAAA,EAAmB;AAAA,GACrB;AACF;AAUO,SAAS,oBACd,UAAA,EACA,KAAA,EACA,SAAA,EACA,WAAA,GAAsB,KACtB,UAAA,EACmB;AACnB,EAAA,MAAM,IAAA,GAAO,WAAW,UAAU,CAAA;AAElC,EAAA,IAAI,IAAA,CAAK,WAAW,CAAA,EAAG;AACrB,IAAA,MAAM,IAAI,MAAM,0BAAM,CAAA;AAAA,EACxB;AAEA,EAAA,IAAI,KAAA,GAAQ,KAAK,MAAA,EAAQ;AACvB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAAQ,KAAK,CAAA,kDAAA,EAAa,IAAA,CAAK,MAAM,CAAA,CAAA,CAAG,CAAA;AAAA,EAC1D;AAGA,EAAA,MAAM,gBAAgB,OAAO,SAAA,KAAc,QAAA,GACvC,sBAAA,CAAuB,SAAS,CAAA,GAChC,SAAA;AAEJ,EAAA,IAAI,KAAA,GAAQ,CAAA;AACZ,EAAA,IAAI,oBAAA,GAAuB,CAAA;AAE3B,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,EAAa,CAAA,EAAA,EAAK;AACpC,IAAA,MAAM,QAAA,GAAW,aAAa,IAAI,CAAA;AAClC,IAAA,MAAM,MAAA,GAAS,SAAA,CAAU,QAAA,EAAU,KAAA,EAAO,WAAW,MAAM,CAAA;AAE3D,IAAA,IAAI;AACF,MAAA,IAAI,aAAA,CAAc,MAAM,CAAA,EAAG;AACzB,QAAA,KAAA,EAAA;AAAA,MACF;AAAA,IACF,SAAS,CAAA,EAAG;AAAA,IAEZ;AAGA,IAAA,MAAM,WAAW,IAAA,CAAK,KAAA,CAAA,CAAQ,CAAA,GAAI,CAAA,IAAK,cAAe,GAAG,CAAA;AACzD,IAAA,IAAI,QAAA,GAAW,wBAAwB,UAAA,EAAY;AACjD,MAAA,oBAAA,GAAuB,QAAA;AACvB,MAAA,UAAA,CAAW,QAAA,EAAU,CAAA,sCAAA,EAAW,QAAQ,CAAA,CAAA,CAAG,CAAA;AAAA,IAC7C;AAAA,EACF;AAEA,EAAA,IAAI,UAAA,EAAY;AACd,IAAA,UAAA,CAAW,KAAK,kDAAU,CAAA;AAAA,EAC5B;AAEA,EAAA,OAAO;AAAA,IACL,KAAA;AAAA,IACA,KAAA,EAAO,WAAA;AAAA,IACP,WAAA,EAAc,QAAQ,WAAA,GAAe,GAAA;AAAA,IACrC,iBAAA,EAAmB;AAAA,GACrB;AACF;AAMO,SAAS,eAAA,CACd,UAAA,EACA,KAAA,EACA,aAAA,EACA,WAAA,EACQ;AACR,EAAA,MAAM,IAAA,GAAO,WAAW,UAAU,CAAA;AAElC,EAAA,IAAI,IAAA,CAAK,MAAA,KAAW,CAAA,IAAK,IAAA,CAAK,SAAS,KAAA,EAAO;AAC5C,IAAA,OAAO,CAAA;AAAA,EACT;AAEA,EAAA,IAAI,KAAA,GAAQ,CAAA;AAEZ,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,EAAa,CAAA,EAAA,EAAK;AACpC,IAAA,MAAM,QAAA,GAAW,aAAa,IAAI,CAAA;AAClC,IAAA,MAAM,MAAA,GAAS,SAAA,CAAU,QAAA,EAAU,KAAA,EAAO,WAAW,MAAM,CAAA;AAE3D,IAAA,IAAI;AACF,MAAA,IAAI,aAAA,CAAc,MAAM,CAAA,EAAG;AACzB,QAAA,KAAA,EAAA;AAAA,MACF;AAAA,IACF,SAAS,CAAA,EAAG;AAAA,IAEZ;AAAA,EACF;AAEA,EAAA,OAAQ,QAAQ,WAAA,GAAe,GAAA;AACjC;AAMO,SAAS,aAAA,CACd,UAAA,EACA,KAAA,EACA,SAAA,EACA,UAAA,EACmB;AACnB,EAAA,MAAM,UAAA,GAAa,WAAW,MAAA,CAAO,CAAC,GAAG,CAAA,KAAM,CAAA,GAAI,GAAG,CAAC,CAAA;AACvD,EAAA,MAAM,eAAe,UAAA,CAAW,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,GAAI,CAAC,CAAA,CAAE,MAAA;AAKnD,EAAA,MAAM,QAAA,GAAW,UAAA,IAAc,EAAA,IAAM,YAAA,IAAgB,MAAM,KAAA,IAAS,CAAA;AAEpE,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,OAAO,cAAA,CAAe,UAAA,EAAY,KAAA,EAAO,SAAA,EAAW,UAAU,CAAA;AAAA,EAChE,CAAA,MAAO;AAEL,IAAA,MAAM,WAAA,GAAc,UAAA,IAAc,EAAA,GAAK,GAAA,GAAS,GAAA;AAChD,IAAA,OAAO,mBAAA,CAAoB,UAAA,EAAY,KAAA,EAAO,SAAA,EAAW,aAAa,UAAU,CAAA;AAAA,EAClF;AACF;;;ACvMO,SAAS,SACd,KAAA,EACA,SAAA,EACA,OACA,UAAA,EACA,OAAA,GAA+B,EAAC,EACZ;AACpB,EAAA,MAAM,EAAE,WAAA,GAAc,GAAA,EAAO,UAAA,EAAW,GAAI,OAAA;AAG5C,EAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,KAAK,CAAA;AAC5C,EAAA,MAAM,UAAA,GAAa,cAAc,MAAA,CAAO,CAAC,GAAG,CAAA,KAAM,CAAA,GAAI,GAAG,CAAC,CAAA;AAE1D,EAAA,IAAI,eAAe,CAAA,EAAG;AACpB,IAAA,MAAM,IAAI,MAAM,oEAAa,CAAA;AAAA,EAC/B;AAEA,EAAA,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,IAAA,OAAW,EAAA,EAAI;AACzC,IAAA,MAAM,IAAI,MAAM,kDAAU,CAAA;AAAA,EAC5B;AAGA,EAAA,UAAA,GAAa,GAAG,+CAAY,CAAA;AAC5B,EAAA,MAAM,aAAA,GAAgB,uBAAuB,SAAS,CAAA;AAGtD,EAAA,UAAA,GAAa,IAAI,+CAAY,CAAA;AAC7B,EAAA,MAAM,WAAA,GAAc,eAAA,CAAgB,aAAA,EAAe,KAAA,EAAO,eAAe,WAAW,CAAA;AAGpF,EAAA,MAAM,SAAA,GAAY,WAAA,GAAc,UAAA,GAAa,UAAA,GAAa,UAAA;AAE1D,EAAA,UAAA,GAAa,IAAI,CAAA,0CAAA,EAAU,SAAA,KAAc,UAAA,GAAa,cAAA,GAAO,cAAI,CAAA,qBAAA,CAAQ,CAAA;AAGzE,EAAA,MAAM,aAAA,GAAgB,wBAAwB,SAAS,CAAA;AASvD,EAAA,MAAM,WAAuB,EAAC;AAC9B,EAAA,MAAM,cAA0B,EAAC;AAEjC,EAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,IAAA,EAAM,KAAA,KAAU;AAC7B,IAAA,IAAI,CAAC,IAAA,EAAM;AACX,IAAA,IAAI,IAAA,CAAK,QAAQ,CAAA,EAAG;AAClB,MAAA,IAAI,aAAA,CAAc,QAAA,CAAS,KAAK,CAAA,EAAG;AACjC,QAAA,QAAA,CAAS,KAAK,EAAE,KAAA,EAAO,IAAA,EAAM,KAAA,EAAO,MAAM,CAAA;AAAA,MAC5C,CAAA,MAAO;AACL,QAAA,WAAA,CAAY,KAAK,EAAE,KAAA,EAAO,IAAA,EAAM,KAAA,EAAO,OAAO,CAAA;AAAA,MAChD;AAAA,IACF;AAAA,EACF,CAAC,CAAA;AAED,EAAA,UAAA,GAAa,IAAI,yCAAW,CAAA;AAG5B,EAAA,MAAM,QAA4B,EAAC;AAEnC,EAAA,IAAI,cAAc,UAAA,EAAY;AAE5B,IAAA,qBAAA,CAAsB,KAAA,EAAO,QAAA,EAAU,WAAA,EAAa,aAAA,EAAe,UAAU,CAAA;AAAA,EAC/E,CAAA,MAAO;AAEL,IAAA,qBAAA,CAAsB,KAAA,EAAO,QAAA,EAAU,WAAA,EAAa,aAAA,EAAe,UAAU,CAAA;AAAA,EAC/E;AAEA,EAAA,UAAA,GAAa,EAAA,EAAI,CAAA,wCAAA,EAAa,KAAA,CAAM,MAAM,CAAA,IAAA,CAAM,CAAA;AAGhD,EAAA,MAAM,aAAa,KAAA,CAAM,MAAA;AACzB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,UAAA,EAAY,CAAA,EAAA,EAAK;AACnC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,IAAA,IAAI,CAAC,IAAA,EAAM;AAEX,IAAA,MAAM,QAAA,GAAW,KAAK,SAAA,CAAU,MAAA,CAAO,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,GAAI,CAAA,EAAG,CAAC,CAAA;AACzD,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,GAAA,CAAI,KAAA,EAAO,QAAQ,CAAA;AAC5C,IAAA,IAAA,CAAK,OAAA,GAAU,eAAA,CAAgB,IAAA,CAAK,SAAA,EAAW,WAAA,EAAa,eAAe,IAAA,CAAK,KAAA,CAAM,WAAA,GAAc,CAAC,CAAC,CAAA;AACtG,IAAA,IAAA,CAAK,WAAA,GAAc,KAAK,OAAA,GAAU,WAAA;AAGlC,IAAA,IAAA,CAAK,cAAc,SAAA,KAAc,UAAA,GAC7B,KAAK,OAAA,IAAW,UAAA,GAChB,KAAK,OAAA,IAAW,UAAA;AAGpB,IAAA,IAAI,CAAA,GAAI,CAAA,KAAM,CAAA,IAAK,CAAA,KAAM,aAAa,CAAA,EAAG;AACvC,MAAA,MAAM,WAAW,EAAA,GAAK,IAAA,CAAK,OAAQ,CAAA,GAAI,CAAA,IAAK,aAAc,EAAE,CAAA;AAC5D,MAAA,UAAA,GAAa,UAAU,CAAA,sCAAA,EAAW,CAAA,GAAI,CAAC,CAAA,CAAA,EAAI,UAAU,CAAA,IAAA,CAAM,CAAA;AAAA,IAC7D;AAAA,EACF;AAEA,EAAA,UAAA,GAAa,IAAI,6BAAS,CAAA;AAG1B,EAAA,MAAM,aAAa,KAAA,CAAM,MAAA;AAAA,IAAO,OAC9B,SAAA,KAAc,UAAA,GAAa,EAAE,WAAA,GAAc,GAAA,GAAM,EAAE,WAAA,GAAc;AAAA,GACnE;AAGA,EAAA,MAAM,gBAAgB,UAAA,CAAW,MAAA;AAAA,IAAO,CAAA,CAAA,KACtC,SAAA,KAAc,UAAA,GACT,CAAA,CAAE,IAAA,KAAS,cAAA,IAAkB,CAAA,CAAE,IAAA,KAAS,oBAAA,GACxC,CAAA,CAAE,IAAA,KAAS,cAAA,IAAkB,EAAE,IAAA,KAAS;AAAA,GAC/C;AACA,EAAA,MAAM,kBAAkB,UAAA,CAAW,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,aAAa,CAAA;AACvE,EAAA,MAAM,kBAAkB,UAAA,CAAW,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,aAAa,CAAA;AAGvE,EAAA,MAAM,SAAA,GAAY,CAAC,GAAA,KAA4B;AAC7C,IAAA,OAAO,GAAA,CAAI,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM;AAExB,MAAA,IAAI,CAAA,CAAE,WAAA,KAAgB,CAAA,CAAE,WAAA,EAAa;AACnC,QAAA,OAAO,CAAA,CAAE,cAAc,EAAA,GAAK,CAAA;AAAA,MAC9B;AAEA,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,UAAA,GAAa,EAAE,OAAO,CAAA;AAC7C,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,UAAA,GAAa,EAAE,OAAO,CAAA;AAC7C,MAAA,OAAO,KAAA,GAAQ,KAAA;AAAA,IACjB,CAAC,CAAA;AAAA,EACH,CAAA;AAGA,EAAA,SAAA,CAAU,aAAa,CAAA;AACvB,EAAA,SAAA,CAAU,eAAe,CAAA;AACzB,EAAA,SAAA,CAAU,eAAe,CAAA;AAGzB,EAAA,IAAI,aAAA,CAAc,SAAS,CAAA,IAAK,aAAA,CAAc,CAAC,CAAA,EAAG,aAAA,CAAc,CAAC,CAAA,CAAE,MAAA,GAAS,IAAA;AAC5E,EAAA,IAAI,eAAA,CAAgB,SAAS,CAAA,IAAK,eAAA,CAAgB,CAAC,CAAA,EAAG,eAAA,CAAgB,CAAC,CAAA,CAAE,MAAA,GAAS,IAAA;AAClF,EAAA,IAAI,eAAA,CAAgB,SAAS,CAAA,IAAK,eAAA,CAAgB,CAAC,CAAA,EAAG,eAAA,CAAgB,CAAC,CAAA,CAAE,MAAA,GAAS,IAAA;AAGlF,EAAA,MAAM,WAAA,GAAc,EAAA;AAEpB,EAAA,UAAA,GAAa,KAAK,oBAAK,CAAA;AAEvB,EAAA,OAAO;AAAA,IACL,WAAA;AAAA,IACA,UAAA;AAAA,IACA,SAAA;AAAA,IACA,aAAA,EAAe,aAAA,CAAc,KAAA,CAAM,CAAA,EAAG,WAAW,CAAA;AAAA,IACjD,eAAA,EAAiB,eAAA,CAAgB,KAAA,CAAM,CAAA,EAAG,WAAW,CAAA;AAAA,IACrD,eAAA,EAAiB,eAAA,CAAgB,KAAA,CAAM,CAAA,EAAG,WAAW,CAAA;AAAA,IACrD,iBAAiB,UAAA,CAAW;AAAA,GAC9B;AACF;AAKA,SAAS,qBAAA,CACP,KAAA,EACA,QAAA,EACA,WAAA,EACA,eACA,UAAA,EACA;AAEA,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,IAAI,CAAC,OAAA,EAAS;AACd,IAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,IAAA,CAAK,QAAA,IAAY,CAAA;AAC7C,IAAA,IAAI,OAAA,CAAQ,IAAA,CAAK,KAAA,GAAQ,WAAA,EAAa;AACpC,MAAA,MAAM,MAAA,GAAS,WAAA,GAAc,OAAA,CAAQ,IAAA,CAAK,KAAA;AAC1C,MAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,IAAO,MAAA,EAAQ,GAAA,EAAA,EAAO;AACtC,QAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAChC,UAAA,IAAI,CAAC,MAAA,EAAQ;AACb,UAAA,IAAI,MAAA,CAAO,IAAA,CAAK,KAAA,IAAS,GAAA,EAAK;AAC5B,YAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,YAAA,MAAM,SAAS,OAAA,CAAQ,KAAA;AACvB,YAAA,MAAM,YAAY,MAAA,CAAO,KAAA;AACzB,YAAA,IAAI,UAAU,MAAM,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,MAAM,CAAA,IAAK,GAAA;AAC1D,YAAA,IAAI,UAAU,SAAS,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,SAAS,CAAA,IAAK,GAAA;AAEhE,YAAA,KAAA,CAAM,IAAA,CAAK;AAAA,cACT,IAAA,EAAM,cAAA;AAAA,cACN,aAAa,CAAA,kBAAA,EAAM,OAAA,CAAQ,KAAK,IAAA,IAAQ,OAAA,CAAQ,KAAK,KAAK,CAAA,MAAA,EAAI,GAAG,CAAA,8BAAA,EAAQ,OAAO,IAAA,CAAK,IAAA,IAAQ,OAAO,IAAA,CAAK,KAAK,SAAI,GAAG,CAAA,MAAA,CAAA;AAAA,cACrH,OAAA,EAAS;AAAA,gBACP,EAAE,IAAA,EAAM,OAAA,CAAQ,IAAA,EAAM,MAAA,EAAQ,CAAC,GAAA,EAAI;AAAA,gBACnC,EAAE,IAAA,EAAM,MAAA,CAAO,IAAA,EAAM,MAAA,EAAQ,CAAC,GAAA;AAAI,eACpC;AAAA,cACA,SAAA;AAAA,cACA,OAAA,EAAS,CAAA;AAAA,cACT,WAAA,EAAa,CAAA;AAAA,cACb,WAAA,EAAa,KAAA;AAAA,cACb,QAAA,EAAU;AAAA,aACX,CAAA;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,QAAA,CAAS,UAAU,CAAA,EAAG;AACxB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AACxC,MAAA,KAAA,IAAS,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AAC5C,QAAA,MAAM,KAAA,GAAQ,SAAS,CAAC,CAAA;AACxB,QAAA,MAAM,KAAA,GAAQ,SAAS,CAAC,CAAA;AACxB,QAAA,IAAI,CAAC,KAAA,IAAS,CAAC,KAAA,EAAO;AAEtB,QAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,IAAA,CAAK,QAAA,IAAY,CAAA;AAC7C,QAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,IAAA,CAAK,QAAA,IAAY,CAAA;AAC7C,QAAA,IAAI,MAAM,IAAA,CAAK,KAAA,GAAQ,iBAAiB,KAAA,CAAM,IAAA,CAAK,QAAQ,aAAA,EAAe;AACxE,UAAA,MAAM,WAAA,GAAc,CAAA;AACpB,UAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAChC,YAAA,IAAI,CAAC,MAAA,EAAQ;AACb,YAAA,IAAI,MAAA,CAAO,IAAA,CAAK,KAAA,IAAS,WAAA,EAAa;AACpC,cAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,cAAA,MAAM,OAAO,KAAA,CAAM,KAAA;AACnB,cAAA,MAAM,OAAO,KAAA,CAAM,KAAA;AACnB,cAAA,MAAM,YAAY,MAAA,CAAO,KAAA;AACzB,cAAA,IAAI,UAAU,IAAI,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,IAAI,CAAA,IAAK,CAAA;AACtD,cAAA,IAAI,UAAU,IAAI,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,IAAI,CAAA,IAAK,CAAA;AACtD,cAAA,IAAI,UAAU,SAAS,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,SAAS,CAAA,IAAK,WAAA;AAEhE,cAAA,KAAA,CAAM,IAAA,CAAK;AAAA,gBACT,IAAA,EAAM,oBAAA;AAAA,gBACN,WAAA,EAAa,qBAAM,KAAA,CAAM,IAAA,CAAK,QAAQ,KAAA,CAAM,IAAA,CAAK,KAAK,CAAA,sBAAA,EAAU,KAAA,CAAM,KAAK,IAAA,IAAQ,KAAA,CAAM,KAAK,KAAK,CAAA,qCAAA,EAAU,OAAO,IAAA,CAAK,IAAA,IAAQ,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,aAAA,CAAA;AAAA,gBAClJ,OAAA,EAAS;AAAA,kBACP,EAAE,IAAA,EAAM,KAAA,CAAM,IAAA,EAAM,QAAQ,CAAA,EAAG;AAAA,kBAC/B,EAAE,IAAA,EAAM,KAAA,CAAM,IAAA,EAAM,QAAQ,CAAA,EAAG;AAAA,kBAC/B,EAAE,IAAA,EAAM,MAAA,CAAO,IAAA,EAAM,QAAQ,EAAA;AAAG,iBAClC;AAAA,gBACA,SAAA;AAAA,gBACA,OAAA,EAAS,CAAA;AAAA,gBACT,WAAA,EAAa,CAAA;AAAA,gBACb,WAAA,EAAa,KAAA;AAAA,gBACb,QAAA,EAAU;AAAA,eACX,CAAA;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,aAAa,EAAA,EAAI;AACnB,IAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,MAAA,IAAI,CAAC,OAAA,EAAS;AACd,MAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,IAAA,CAAK,QAAA,IAAY,CAAA;AAC7C,MAAA,IAAI,OAAA,CAAQ,IAAA,CAAK,KAAA,GAAQ,WAAA,EAAa;AACpC,QAAA,MAAM,SAAA,GAAY,WAAA,GAAc,OAAA,CAAQ,IAAA,CAAK,KAAA;AAC7C,QAAA,MAAM,YAAY,EAAA,GAAK,UAAA;AACvB,QAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,SAAA,EAAW,WAAW,CAAC,CAAA;AAE/C,QAAA,IAAI,SAAS,CAAA,EAAG;AACd,UAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,IAAO,MAAA,EAAQ,GAAA,EAAA,EAAO;AACtC,YAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,YAAA,MAAM,MAAM,OAAA,CAAQ,KAAA;AACpB,YAAA,IAAI,UAAU,GAAG,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,GAAG,CAAA,IAAK,GAAA;AAEpD,YAAA,KAAA,CAAM,IAAA,CAAK;AAAA,cACT,IAAA,EAAM,aAAA;AAAA,cACN,WAAA,EAAa,CAAA,kBAAA,EAAM,OAAA,CAAQ,IAAA,CAAK,QAAQ,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA,MAAA,EAAI,GAAG,CAAA,8BAAA,EAAQ,UAAU,CAAA,kBAAA,EAAM,aAAa,GAAG,CAAA,YAAA,CAAA;AAAA,cACzG,OAAA,EAAS,CAAC,EAAE,IAAA,EAAM,QAAQ,IAAA,EAAM,MAAA,EAAQ,CAAC,GAAA,EAAK,CAAA;AAAA,cAC9C,SAAA;AAAA,cACA,aAAa,UAAA,GAAa,GAAA;AAAA,cAC1B,OAAA,EAAS,CAAA;AAAA,cACT,WAAA,EAAa,CAAA;AAAA,cACb,WAAA,EAAa,KAAA;AAAA,cACb,QAAA,EAAU;AAAA,aACX,CAAA;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAChC,IAAA,IAAI,CAAC,MAAA,EAAQ;AACb,IAAA,IAAI,MAAA,CAAO,IAAA,CAAK,KAAA,IAAS,CAAA,IAAK,aAAa,EAAA,EAAI;AAC7C,MAAA,MAAM,SAAA,GAAY,KAAK,GAAA,CAAI,MAAA,CAAO,KAAK,KAAA,EAAO,UAAA,GAAa,IAAI,CAAC,CAAA;AAEhE,MAAA,KAAA,IAAS,MAAA,GAAS,CAAA,EAAG,MAAA,IAAU,SAAA,EAAW,MAAA,EAAA,EAAU;AAClD,QAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,QAAA,MAAM,MAAM,MAAA,CAAO,KAAA;AACnB,QAAA,IAAI,UAAU,GAAG,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,GAAG,CAAA,IAAK,MAAA;AAEpD,QAAA,KAAA,CAAM,IAAA,CAAK;AAAA,UACT,IAAA,EAAM,aAAA;AAAA,UACN,WAAA,EAAa,CAAA,kBAAA,EAAM,MAAA,CAAO,IAAA,CAAK,QAAQ,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,MAAA,EAAI,MAAM,CAAA,8BAAA,EAAQ,UAAU,CAAA,kBAAA,EAAM,aAAa,MAAM,CAAA,YAAA,CAAA;AAAA,UAC7G,OAAA,EAAS,CAAC,EAAE,IAAA,EAAM,OAAO,IAAA,EAAM,MAAA,EAAQ,CAAC,MAAA,EAAQ,CAAA;AAAA,UAChD,SAAA;AAAA,UACA,aAAa,UAAA,GAAa,MAAA;AAAA,UAC1B,OAAA,EAAS,CAAA;AAAA,UACT,WAAA,EAAa,CAAA;AAAA,UACb,WAAA,EAAa,KAAA;AAAA,UACb,QAAA,EAAU;AAAA,SACX,CAAA;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;AAKA,SAAS,qBAAA,CACP,KAAA,EACA,QAAA,EACA,WAAA,EACA,eACA,UAAA,EACA;AAEA,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,IAAI,CAAC,OAAA,EAAS;AACd,IAAA,IAAI,OAAA,CAAQ,IAAA,CAAK,KAAA,IAAS,CAAA,EAAG;AAC3B,MAAA,MAAM,SAAA,GAAY,QAAQ,IAAA,CAAK,KAAA;AAC/B,MAAA,KAAA,IAAS,MAAA,GAAS,GAAG,MAAA,IAAU,IAAA,CAAK,IAAI,SAAA,EAAW,CAAC,GAAG,MAAA,EAAA,EAAU;AAC/D,QAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAChC,UAAA,IAAI,CAAC,MAAA,EAAQ;AACb,UAAA,MAAM,cAAA,GAAiB,MAAA,CAAO,IAAA,CAAK,QAAA,IAAY,CAAA;AAC/C,UAAA,IAAI,MAAA,CAAO,IAAA,CAAK,KAAA,GAAQ,cAAA,EAAgB;AAEtC,YAAA,MAAM,SAAS,IAAA,CAAK,GAAA,CAAI,QAAQ,cAAA,GAAiB,MAAA,CAAO,KAAK,KAAK,CAAA;AAClE,YAAA,IAAI,UAAU,MAAA,EAAQ;AACpB,cAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,cAAA,MAAM,SAAS,OAAA,CAAQ,KAAA;AACvB,cAAA,MAAM,YAAY,MAAA,CAAO,KAAA;AACzB,cAAA,IAAI,UAAU,MAAM,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,MAAM,CAAA,IAAK,MAAA;AAC1D,cAAA,IAAI,UAAU,SAAS,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,SAAS,CAAA,IAAK,MAAA;AAEhE,cAAA,KAAA,CAAM,IAAA,CAAK;AAAA,gBACT,IAAA,EAAM,cAAA;AAAA,gBACN,aAAa,CAAA,kBAAA,EAAM,OAAA,CAAQ,KAAK,IAAA,IAAQ,OAAA,CAAQ,KAAK,KAAK,CAAA,MAAA,EAAI,MAAM,CAAA,8BAAA,EAAQ,OAAO,IAAA,CAAK,IAAA,IAAQ,OAAO,IAAA,CAAK,KAAK,SAAI,MAAM,CAAA,MAAA,CAAA;AAAA,gBAC3H,OAAA,EAAS;AAAA,kBACP,EAAE,IAAA,EAAM,OAAA,CAAQ,IAAA,EAAM,MAAA,EAAQ,CAAC,MAAA,EAAO;AAAA,kBACtC,EAAE,IAAA,EAAM,MAAA,CAAO,IAAA,EAAM,MAAA,EAAQ,CAAC,MAAA;AAAO,iBACvC;AAAA,gBACA,SAAA;AAAA,gBACA,OAAA,EAAS,CAAA;AAAA,gBACT,WAAA,EAAa,CAAA;AAAA,gBACb,WAAA,EAAa,KAAA;AAAA,gBACb,QAAA,EAAU;AAAA,eACX,CAAA;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,QAAA,CAAS,UAAU,CAAA,EAAG;AACxB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AACxC,MAAA,KAAA,IAAS,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,CAAS,QAAQ,CAAA,EAAA,EAAK;AAC5C,QAAA,MAAM,KAAA,GAAQ,SAAS,CAAC,CAAA;AACxB,QAAA,MAAM,KAAA,GAAQ,SAAS,CAAC,CAAA;AACxB,QAAA,IAAI,CAAC,KAAA,IAAS,CAAC,KAAA,EAAO;AACtB,QAAA,IAAI,MAAM,IAAA,CAAK,KAAA,IAAS,KAAK,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA,EAAG;AAClD,UAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAChC,YAAA,IAAI,CAAC,MAAA,EAAQ;AACb,YAAA,MAAM,cAAA,GAAiB,MAAA,CAAO,IAAA,CAAK,QAAA,IAAY,CAAA;AAE/C,YAAA,IAAI,MAAA,CAAO,IAAA,CAAK,KAAA,GAAQ,CAAA,IAAK,cAAA,EAAgB;AAC3C,cAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,cAAA,MAAM,OAAO,KAAA,CAAM,KAAA;AACnB,cAAA,MAAM,OAAO,KAAA,CAAM,KAAA;AACnB,cAAA,MAAM,YAAY,MAAA,CAAO,KAAA;AACzB,cAAA,IAAI,UAAU,IAAI,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,IAAI,CAAA,IAAK,CAAA;AACtD,cAAA,IAAI,UAAU,IAAI,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,IAAI,CAAA,IAAK,CAAA;AACtD,cAAA,IAAI,UAAU,SAAS,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,SAAS,CAAA,IAAK,CAAA;AAEhE,cAAA,KAAA,CAAM,IAAA,CAAK;AAAA,gBACT,IAAA,EAAM,oBAAA;AAAA,gBACN,WAAA,EAAa,qBAAM,KAAA,CAAM,IAAA,CAAK,QAAQ,KAAA,CAAM,IAAA,CAAK,KAAK,CAAA,sBAAA,EAAU,KAAA,CAAM,KAAK,IAAA,IAAQ,KAAA,CAAM,KAAK,KAAK,CAAA,qCAAA,EAAU,OAAO,IAAA,CAAK,IAAA,IAAQ,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,aAAA,CAAA;AAAA,gBAClJ,OAAA,EAAS;AAAA,kBACP,EAAE,IAAA,EAAM,KAAA,CAAM,IAAA,EAAM,QAAQ,EAAA,EAAG;AAAA,kBAC/B,EAAE,IAAA,EAAM,KAAA,CAAM,IAAA,EAAM,QAAQ,EAAA,EAAG;AAAA,kBAC/B,EAAE,IAAA,EAAM,MAAA,CAAO,IAAA,EAAM,QAAQ,CAAA;AAAG,iBAClC;AAAA,gBACA,SAAA;AAAA,gBACA,OAAA,EAAS,CAAA;AAAA,gBACT,WAAA,EAAa,CAAA;AAAA,gBACb,WAAA,EAAa,KAAA;AAAA,gBACb,QAAA,EAAU;AAAA,eACX,CAAA;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,aAAa,EAAA,EAAI;AACnB,IAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAChC,MAAA,IAAI,CAAC,MAAA,EAAQ;AACb,MAAA,MAAM,cAAA,GAAiB,MAAA,CAAO,IAAA,CAAK,QAAA,IAAY,CAAA;AAC/C,MAAA,IAAI,MAAA,CAAO,IAAA,CAAK,KAAA,GAAQ,cAAA,EAAgB;AACtC,QAAA,MAAM,SAAA,GAAY,cAAA,GAAiB,MAAA,CAAO,IAAA,CAAK,KAAA;AAC/C,QAAA,MAAM,YAAY,EAAA,GAAK,UAAA;AACvB,QAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,CAAI,SAAA,EAAW,WAAW,CAAC,CAAA;AAE/C,QAAA,IAAI,SAAS,CAAA,EAAG;AACd,UAAA,KAAA,IAAS,GAAA,GAAM,CAAA,EAAG,GAAA,IAAO,MAAA,EAAQ,GAAA,EAAA,EAAO;AACtC,YAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,YAAA,MAAM,MAAM,MAAA,CAAO,KAAA;AACnB,YAAA,IAAI,UAAU,GAAG,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,GAAG,CAAA,IAAK,GAAA;AAEpD,YAAA,KAAA,CAAM,IAAA,CAAK;AAAA,cACT,IAAA,EAAM,aAAA;AAAA,cACN,WAAA,EAAa,CAAA,kBAAA,EAAM,MAAA,CAAO,IAAA,CAAK,QAAQ,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,MAAA,EAAI,GAAG,CAAA,8BAAA,EAAQ,UAAU,CAAA,kBAAA,EAAM,aAAa,GAAG,CAAA,YAAA,CAAA;AAAA,cACvG,OAAA,EAAS,CAAC,EAAE,IAAA,EAAM,OAAO,IAAA,EAAM,MAAA,EAAQ,CAAC,GAAA,EAAK,CAAA;AAAA,cAC7C,SAAA;AAAA,cACA,aAAa,UAAA,GAAa,GAAA;AAAA,cAC1B,OAAA,EAAS,CAAA;AAAA,cACT,WAAA,EAAa,CAAA;AAAA,cACb,WAAA,EAAa,KAAA;AAAA,cACb,QAAA,EAAU;AAAA,aACX,CAAA;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,IAAI,CAAC,OAAA,EAAS;AACd,IAAA,IAAI,OAAA,CAAQ,IAAA,CAAK,KAAA,IAAS,CAAA,IAAK,aAAa,EAAA,EAAI;AAC9C,MAAA,MAAM,SAAA,GAAY,KAAK,GAAA,CAAI,OAAA,CAAQ,KAAK,KAAA,EAAO,UAAA,GAAa,IAAI,CAAC,CAAA;AAEjE,MAAA,KAAA,IAAS,MAAA,GAAS,CAAA,EAAG,MAAA,IAAU,SAAA,EAAW,MAAA,EAAA,EAAU;AAClD,QAAA,MAAM,SAAA,GAAY,CAAC,GAAG,aAAa,CAAA;AACnC,QAAA,MAAM,MAAM,OAAA,CAAQ,KAAA;AACpB,QAAA,IAAI,UAAU,GAAG,CAAA,KAAM,MAAA,EAAW,SAAA,CAAU,GAAG,CAAA,IAAK,MAAA;AAEpD,QAAA,KAAA,CAAM,IAAA,CAAK;AAAA,UACT,IAAA,EAAM,aAAA;AAAA,UACN,WAAA,EAAa,CAAA,kBAAA,EAAM,OAAA,CAAQ,IAAA,CAAK,QAAQ,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA,MAAA,EAAI,MAAM,CAAA,8BAAA,EAAQ,UAAU,CAAA,kBAAA,EAAM,aAAa,MAAM,CAAA,YAAA,CAAA;AAAA,UAC/G,OAAA,EAAS,CAAC,EAAE,IAAA,EAAM,QAAQ,IAAA,EAAM,MAAA,EAAQ,CAAC,MAAA,EAAQ,CAAA;AAAA,UACjD,SAAA;AAAA,UACA,aAAa,UAAA,GAAa,MAAA;AAAA,UAC1B,OAAA,EAAS,CAAA;AAAA,UACT,WAAA,EAAa,CAAA;AAAA,UACb,WAAA,EAAa,KAAA;AAAA,UACb,QAAA,EAAU;AAAA,SACX,CAAA;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;AAKO,SAAS,SAAA,CAAU,MAAwB,KAAA,EAAqB;AACrE,EAAA,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAA,MAAA,KAAU;AAE7B,IAAA,MAAM,SAAA,GAAY,KAAA,CAAM,SAAA,CAAU,CAAA,CAAA,KAAK;AACrC,MAAA,IAAI,OAAO,IAAA,CAAK,KAAA,IAAS,EAAE,KAAA,KAAU,MAAA,CAAO,KAAK,KAAA,EAAO;AACtD,QAAA,OAAO,IAAA;AAAA,MACT;AACA,MAAA,IAAI,MAAA,CAAO,KAAK,IAAA,IAAQ,CAAA,CAAE,QAAQ,CAAA,CAAE,IAAA,KAAS,MAAA,CAAO,IAAA,CAAK,IAAA,EAAM;AAC7D,QAAA,OAAO,IAAA;AAAA,MACT;AACA,MAAA,OAAO,KAAA;AAAA,IACT,CAAC,CAAA;AAED,IAAA,IAAI,cAAc,EAAA,EAAI;AACpB,MAAA,MAAM,IAAA,GAAO,MAAM,SAAS,CAAA;AAC5B,MAAA,IAAI,IAAA,EAAM;AACR,QAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,GAAA,CAAI,GAAG,IAAA,CAAK,KAAA,GAAQ,OAAO,MAAM,CAAA;AAAA,MACrD;AAAA,IACF;AAAA,EACF,CAAC,CAAA;AACH;;;ACneO,SAAS,uBAAA,GAAkC;AAChD,EAAA,OAAO;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA,CAAA,CAgFL,IAAA,EAAK;AACT;AAKO,SAAS,4BAAA,GAAuC;AACrD,EAAA,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA,CAAA,CAqFL,IAAA,EAAK;AACT;AAKO,SAAS,2BAAA,GAAsC;AACpD,EAAA,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA,CAAA,CA8bL,IAAA,EAAK;AACT","file":"index.cjs","sourcesContent":["/**\r\n * 工具函数模块\r\n */\r\n\r\n/**\r\n * 变量名转索引\r\n * @example\r\n * varToIndex('a') // 0\r\n * varToIndex('z') // 25\r\n * varToIndex('aa') // 26\r\n */\r\nexport function varToIndex(varName: string): number {\r\n  const lc = varName.toLowerCase()\r\n  \r\n  // 单字母: a-z -> 0-25\r\n  if (lc.length === 1) {\r\n    const code = lc.charCodeAt(0) - 97\r\n    if (code >= 0 && code < 26) return code\r\n  }\r\n  \r\n  // 双字母: aa-ad -> 26-29\r\n  if (lc.length === 2 && lc[0] === 'a') {\r\n    const code = lc.charCodeAt(1) - 97\r\n    if (code >= 0 && code < 4) return 26 + code\r\n  }\r\n  \r\n  throw new Error(`无效的卡名称: ${varName}`)\r\n}\r\n\r\n/**\r\n * 索引转变量名\r\n * @example\r\n * indexToVar(0) // 'a'\r\n * indexToVar(25) // 'z'\r\n * indexToVar(26) // 'aa'\r\n */\r\nexport function indexToVar(index: number): string {\r\n  if (index < 0 || index >= 30) {\r\n    throw new Error(`索引超出范围: ${index}`)\r\n  }\r\n  \r\n  if (index < 26) {\r\n    return String.fromCharCode(97 + index)\r\n  }\r\n  \r\n  return 'a' + String.fromCharCode(97 + index - 26)\r\n}\r\n\r\n/**\r\n * 索引转标签\r\n * @example\r\n * indexToLabel(0) // 'A'\r\n * indexToLabel(25) // 'Z'\r\n * indexToLabel(26) // 'AA'\r\n */\r\nexport function indexToLabel(index: number): string {\r\n  if (index < 0 || index >= 30) {\r\n    throw new Error(`索引超出范围: ${index}`)\r\n  }\r\n  \r\n  if (index < 26) {\r\n    return String.fromCharCode(65 + index)\r\n  }\r\n  \r\n  return 'A' + String.fromCharCode(65 + index - 26)\r\n}\r\n\r\n/**\r\n * 组合数缓存\r\n */\r\nconst combinationCache = new Map<string, bigint>()\r\n\r\n/**\r\n * 计算组合数 C(n, k)\r\n */\r\nexport function combination(n: number | bigint, k: number | bigint): bigint {\r\n  const nBig = BigInt(n)\r\n  const kBig = BigInt(k)\r\n  \r\n  if (kBig < 0n || kBig > nBig) return 0n\r\n  if (kBig === 0n || kBig === nBig) return 1n\r\n  \r\n  const key = `${nBig},${kBig}`\r\n  if (combinationCache.has(key)) {\r\n    return combinationCache.get(key)!\r\n  }\r\n  \r\n  let result = 1n\r\n  for (let i = 1n; i <= kBig; i++) {\r\n    result = result * (nBig - kBig + i) / i\r\n  }\r\n  \r\n  combinationCache.set(key, result)\r\n  return result\r\n}\r\n\r\n/**\r\n * 清除组合数缓存\r\n */\r\nexport function clearCombinationCache(): void {\r\n  combinationCache.clear()\r\n}\r\n\r\n/**\r\n * 洗牌算法（Fisher-Yates）\r\n */\r\nexport function shuffleArray<T>(array: T[]): T[] {\r\n  const result = [...array]\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    const temp = result[i]\r\n    result[i] = result[j]!\r\n    result[j] = temp!\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * 从卡组中抽卡并统计\r\n */\r\nexport function drawCards(deck: number[], draws: number, cardTypeCount: number): number[] {\r\n  const counts = Array(cardTypeCount).fill(0)\r\n  const drawn = deck.slice(0, draws)\r\n  drawn.forEach(idx => {\r\n    counts[idx]++\r\n  })\r\n  return counts\r\n}\r\n\r\n/**\r\n * 创建卡组（扩展数组）\r\n */\r\nexport function createDeck(cardCounts: number[]): number[] {\r\n  const deck: number[] = []\r\n  for (let i = 0; i < cardCounts.length; i++) {\r\n    const count = cardCounts[i]\r\n    if (count !== undefined) {\r\n      for (let j = 0; j < count; j++) {\r\n        deck.push(i)\r\n      }\r\n    }\r\n  }\r\n  return deck\r\n}\r\n\r\n/**\r\n * 转义正则表达式特殊字符\r\n */\r\nexport function escapeRegExp(str: string): string {\r\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\r\n}\r\n\r\n","/**\r\n * 条件表达式解析和编译模块\r\n */\r\n\r\nimport type { \r\n  ConditionNode, \r\n  SingleConditionNode, \r\n  LogicalConditionNode,\r\n  ConditionFunction,\r\n  CardNameMap\r\n} from './types'\r\nimport { varToIndex, escapeRegExp } from './utils'\r\n\r\n/**\r\n * 操作符映射\r\n */\r\nconst OPERATOR_MAP: Record<string, 'gt' | 'lt' | 'eq' | 'neq' | 'gte' | 'lte'> = {\r\n  '>': 'gt',\r\n  '<': 'lt',\r\n  '==': 'eq',\r\n  '!=': 'neq',\r\n  '>=': 'gte',\r\n  '<=': 'lte'\r\n}\r\n\r\nconst OPERATOR_SYMBOLS: Record<string, string> = {\r\n  'gt': '>',\r\n  'lt': '<',\r\n  'eq': '==',\r\n  'neq': '!=',\r\n  'gte': '>=',\r\n  'lte': '<='\r\n}\r\n\r\n/**\r\n * Token 解析器\r\n */\r\nclass Parser {\r\n  private tokens: string[]\r\n  private pos: number = 0\r\n\r\n  constructor(tokens: string[]) {\r\n    this.tokens = tokens\r\n  }\r\n\r\n  peek(): string | undefined {\r\n    return this.tokens[this.pos]\r\n  }\r\n\r\n  consume(expected?: string): string {\r\n    const token = this.tokens[this.pos]\r\n    if (expected && token !== expected) {\r\n      throw new Error(`预期 ${expected}，但得到 ${token || '结束'}`)\r\n    }\r\n    if (!token) {\r\n      throw new Error('意外的结束')\r\n    }\r\n    this.pos++\r\n    return token\r\n  }\r\n\r\n  eof(): boolean {\r\n    return this.pos >= this.tokens.length\r\n  }\r\n\r\n  remaining(): string {\r\n    return this.tokens.slice(this.pos).join(' ')\r\n  }\r\n  \r\n  getPos(): number {\r\n    return this.pos\r\n  }\r\n  \r\n  setPos(pos: number): void {\r\n    this.pos = pos\r\n  }\r\n}\r\n\r\n/**\r\n * 词法分析：将表达式字符串分解为 token\r\n */\r\nfunction tokenize(expr: string): string[] {\r\n  // 支持：字母、数字、中文、下划线组成的标识符\r\n  // 支持：>=, <=, ==, !=, &&, ||\r\n  // 支持：+, -, *, /, (, ), <, >\r\n  const regex = /\\s*([A-Za-z0-9_\\u4e00-\\u9fa5]+|>=|<=|==|!=|&&|\\|\\||[-+*/()<>])\\s*/g\r\n  const tokens: string[] = []\r\n  let m: RegExpExecArray | null\r\n  let lastIndex = 0\r\n  \r\n  while ((m = regex.exec(expr)) !== null) {\r\n    // 检查是否有未匹配的字符\r\n    if (m.index > lastIndex) {\r\n      const skipped = expr.substring(lastIndex, m.index).trim()\r\n      if (skipped) {\r\n        throw new Error(`不支持的字符: \"${skipped}\"`)\r\n      }\r\n    }\r\n    const token = m[1]\r\n    if (token) tokens.push(token)\r\n    lastIndex = regex.lastIndex\r\n  }\r\n  \r\n  // 检查末尾是否有未匹配的字符\r\n  const remaining = expr.substring(lastIndex).trim()\r\n  if (remaining) {\r\n    throw new Error(`不支持的字符: \"${remaining}\"`)\r\n  }\r\n  \r\n  return tokens\r\n}\r\n\r\n/**\r\n * 解析表达式\r\n */\r\nfunction parseExpression(parser: Parser): ConditionNode {\r\n  return parseLogicalOr(parser)\r\n}\r\n\r\n/**\r\n * 解析逻辑或\r\n */\r\nfunction parseLogicalOr(parser: Parser): ConditionNode {\r\n  let node = parseLogicalAnd(parser)\r\n  \r\n  while (!parser.eof()) {\r\n    const peek = parser.peek()\r\n    if (peek !== '||') break\r\n    parser.consume('||')\r\n    const right = parseLogicalAnd(parser)\r\n    node = { type: 'or', children: [node, right] } as LogicalConditionNode\r\n  }\r\n  \r\n  return node\r\n}\r\n\r\n/**\r\n * 解析逻辑与\r\n */\r\nfunction parseLogicalAnd(parser: Parser): ConditionNode {\r\n  let node = parseRelational(parser)\r\n  \r\n  while (!parser.eof()) {\r\n    const peek = parser.peek()\r\n    if (peek !== '&&') break\r\n    parser.consume('&&')\r\n    const right = parseRelational(parser)\r\n    node = { type: 'and', children: [node, right] } as LogicalConditionNode\r\n  }\r\n  \r\n  return node\r\n}\r\n\r\n/**\r\n * 解析关系表达式\r\n */\r\nfunction parseRelational(parser: Parser): ConditionNode {\r\n  const left = parseSum(parser)\r\n  \r\n  // 如果 left 已经是一个条件对象（从括号表达式返回），直接返回\r\n  if (typeof left === 'object' && !Array.isArray(left) && 'type' in left) {\r\n    return left as ConditionNode\r\n  }\r\n  \r\n  const peek = parser.peek()\r\n  if (!parser.eof() && peek && /^(>=|<=|==|!=|>|<)$/.test(peek)) {\r\n    const op = parser.consume()\r\n    const num = parser.consume()\r\n    \r\n    if (!/^\\d+$/.test(num)) {\r\n      throw new Error(`预期数字，但得到 ${num || '结束'}`)\r\n    }\r\n\r\n    const cards: SingleConditionNode['cards'] = []\r\n    \r\n    if (Array.isArray(left)) {\r\n      const first = left[0]\r\n      if (!first) throw new Error('表达式为空')\r\n      cards.push({ name: first })\r\n      for (let i = 1; i < left.length; i += 2) {\r\n        const operator = left[i] as '+' | '-' | '*' | '/'\r\n        const operand = left[i + 1]\r\n        if (!operand) throw new Error('表达式不完整')\r\n        cards.push({ operator, name: operand })\r\n      }\r\n    } else if (typeof left === 'string') {\r\n      cards.push({ name: left })\r\n    } else {\r\n      throw new Error(`无法解析表达式左侧: ${JSON.stringify(left)}`)\r\n    }\r\n\r\n    const symbol = OPERATOR_MAP[op]\r\n    if (!symbol) {\r\n      throw new Error(`不支持的运算符: ${op}`)\r\n    }\r\n\r\n    return {\r\n      type: 'single',\r\n      cards,\r\n      symbol,\r\n      num\r\n    }\r\n  }\r\n  \r\n  // 如果没有比较运算符，抛出错误\r\n  throw new Error(`无效的表达式: ${JSON.stringify(left)}`)\r\n}\r\n\r\n/**\r\n * 解析求和表达式\r\n */\r\nfunction parseSum(parser: Parser): ConditionNode | string | string[] {\r\n  if (parser.peek() === '(') {\r\n    parser.consume('(')\r\n    \r\n    // 尝试解析括号内的内容\r\n    const startPos = parser.getPos()\r\n    try {\r\n      const node = parseExpression(parser)\r\n      if (parser.peek() === ')') {\r\n        parser.consume(')')\r\n        return node\r\n      }\r\n    } catch (e) {\r\n      // 解析失败，回溯\r\n      parser.setPos(startPos)\r\n    }\r\n    \r\n    // 如果不是完整表达式，作为操作数求和解析\r\n    parser.setPos(startPos)\r\n    const items: string[] = []\r\n    items.push(parser.consume())\r\n    \r\n    while (!parser.eof()) {\r\n      const peek = parser.peek()\r\n      if (!peek || !['+', '-', '*', '/'].includes(peek)) break\r\n      const operator = parser.consume()\r\n      items.push(operator)\r\n      const operand = parser.consume()\r\n      items.push(operand)\r\n    }\r\n    \r\n    parser.consume(')')\r\n    const first = items[0]\r\n    return items.length === 1 && first ? first : items\r\n  }\r\n\r\n  // 没有括号，直接解析标识符或数字\r\n  const items: string[] = []\r\n  const first = parser.consume()\r\n  items.push(first)\r\n  \r\n  while (!parser.eof()) {\r\n    const peek = parser.peek()\r\n    if (!peek || !['+', '-', '*', '/'].includes(peek)) break\r\n    const operator = parser.consume()\r\n    items.push(operator)\r\n    const operand = parser.consume()\r\n    items.push(operand)\r\n  }\r\n  \r\n  const firstItem = items[0]\r\n  return items.length === 1 && firstItem ? firstItem : items\r\n}\r\n\r\n/**\r\n * 展平条件结构（合并相同类型的嵌套）\r\n */\r\nfunction flattenCondition(condition: ConditionNode): ConditionNode {\r\n  if (condition.type === 'single') {\r\n    return condition\r\n  }\r\n  \r\n  const flatChildren: ConditionNode[] = []\r\n  for (const child of condition.children) {\r\n    const flatChild = flattenCondition(child)\r\n    // 如果子节点和父节点类型相同，展平它\r\n    if (flatChild.type === condition.type) {\r\n      flatChildren.push(...(flatChild as LogicalConditionNode).children)\r\n    } else {\r\n      flatChildren.push(flatChild)\r\n    }\r\n  }\r\n  \r\n  return { type: condition.type, children: flatChildren }\r\n}\r\n\r\n/**\r\n * 解析条件表达式字符串\r\n * @param expr 条件表达式字符串\r\n * @returns 条件节点\r\n */\r\nexport function parseCondition(expr: string): ConditionNode {\r\n  const trimmed = expr.trim()\r\n  if (!trimmed) {\r\n    throw new Error('空的条件表达式')\r\n  }\r\n\r\n  const tokens = tokenize(trimmed)\r\n  if (tokens.length === 0) {\r\n    throw new Error('无法解析条件：无有效标记')\r\n  }\r\n  \r\n  const parser = new Parser(tokens)\r\n  const tree = parseExpression(parser)\r\n\r\n  if (!parser.eof()) {\r\n    throw new Error(`无法解析条件：${trimmed}（剩余: ${parser.remaining()}）`)\r\n  }\r\n\r\n  // 规范化结果：确保返回的是 and/or 类型的根节点\r\n  if (tree.type === 'single') {\r\n    return { type: 'and', children: [tree] }\r\n  }\r\n\r\n  // 展平不必要的嵌套\r\n  return flattenCondition(tree)\r\n}\r\n\r\n/**\r\n * 条件节点转字符串\r\n */\r\nexport function conditionToString(condition: ConditionNode): string {\r\n  if (condition.type === 'single') {\r\n    const cardsText = condition.cards\r\n      .map((c, i) => i === 0 ? c.name : `${c.operator || '+'} ${c.name}`)\r\n      .join(' ')\r\n    const operator = OPERATOR_SYMBOLS[condition.symbol] || condition.symbol\r\n    return `(${cardsText}) ${operator} ${condition.num}`\r\n  }\r\n\r\n  const childrenText = condition.children\r\n    .map(conditionToString)\r\n    .filter(Boolean)\r\n  \r\n  return childrenText.length > 1\r\n    ? `(${childrenText.join(condition.type === 'and' ? ' && ' : ' || ')})`\r\n    : childrenText[0] || ''\r\n}\r\n\r\n/**\r\n * 编译条件节点为可执行函数\r\n */\r\nexport function compileCondition(condition: ConditionNode): ConditionFunction {\r\n  if (condition.type === 'single') {\r\n    // 生成表达式\r\n    let expr = ''\r\n    condition.cards.forEach((card, i) => {\r\n      if (i === 0) {\r\n        expr += `counts[${varToIndex(card.name)}]`\r\n      } else {\r\n        expr += ` ${card.operator || '+'} counts[${varToIndex(card.name)}]`\r\n      }\r\n    })\r\n    \r\n    const op = OPERATOR_SYMBOLS[condition.symbol]\r\n    if (!op) {\r\n      throw new Error(`不支持的运算符: ${condition.symbol}`)\r\n    }\r\n    expr = `(${expr}) ${op} ${condition.num}`\r\n    \r\n    return new Function('counts', `return ${expr}`) as ConditionFunction\r\n  }\r\n  \r\n  // 递归编译子条件\r\n  const childFuncs = condition.children.map(compileCondition)\r\n  \r\n  if (condition.type === 'and') {\r\n    return (counts: number[]) => childFuncs.every(fn => fn(counts))\r\n  } else {\r\n    return (counts: number[]) => childFuncs.some(fn => fn(counts))\r\n  }\r\n}\r\n\r\n/**\r\n * 编译条件字符串为可执行函数\r\n */\r\nexport function compileConditionString(expr: string): ConditionFunction {\r\n  const condition = parseCondition(expr)\r\n  return compileCondition(condition)\r\n}\r\n\r\n/**\r\n * 提取条件中使用的变量索引\r\n */\r\nexport function parseConditionVariables(expr: string): number[] {\r\n  const varRegex = /([a-zA-Z]+)/g\r\n  const variables = new Set<number>()\r\n  let match: RegExpExecArray | null\r\n  \r\n  while ((match = varRegex.exec(expr)) !== null) {\r\n    try {\r\n      const varName = match[1]\r\n      if (varName) {\r\n        const idx = varToIndex(varName)\r\n        variables.add(idx)\r\n      }\r\n    } catch {\r\n      // 忽略无效变量\r\n    }\r\n  }\r\n  \r\n  return Array.from(variables).sort((a, b) => a - b)\r\n}\r\n\r\n/**\r\n * 替换条件表达式中的卡牌名称为变量名\r\n * @param expr 条件表达式\r\n * @param nameMap 卡牌名称到变量名的映射\r\n */\r\nexport function replaceCardNames(expr: string, nameMap: CardNameMap): string {\r\n  let result = expr\r\n  \r\n  // 按长度从长到短排序，避免短名称替换导致长名称无法匹配\r\n  const sortedNames = Object.keys(nameMap).sort((a, b) => b.length - a.length)\r\n  \r\n  for (const name of sortedNames) {\r\n    const replacement = nameMap[name]\r\n    if (!replacement) continue\r\n    const regex = new RegExp(escapeRegExp(name), 'g')\r\n    result = result.replace(regex, replacement)\r\n  }\r\n  \r\n  return result\r\n}\r\n\r\n","/**\r\n * 概率计算模块\r\n */\r\n\r\nimport type { CalculationResult, ProgressCallback, ConditionFunction } from './types'\r\nimport { combination, shuffleArray, drawCards, createDeck } from './utils'\r\nimport { compileConditionString } from './condition'\r\n\r\n/**\r\n * 精确计算概率\r\n * @param cardCounts 各种卡牌的数量数组\r\n * @param draws 抽取的卡牌数\r\n * @param condition 条件表达式字符串\r\n * @param onProgress 进度回调\r\n */\r\nexport function calculateExact(\r\n  cardCounts: number[],\r\n  draws: number,\r\n  condition: string,\r\n  onProgress?: ProgressCallback\r\n): CalculationResult {\r\n  const totalCards = cardCounts.reduce((a, b) => a + b, 0)\r\n  \r\n  if (totalCards === 0) {\r\n    throw new Error('卡组为空')\r\n  }\r\n  \r\n  if (draws > totalCards) {\r\n    throw new Error(`抽取数量(${draws})不能大于卡组总数(${totalCards})`)\r\n  }\r\n  \r\n  // 编译条件\r\n  const conditionFunc = compileConditionString(condition)\r\n  \r\n  let valid = 0n\r\n  let total = 0n\r\n  let lastReportedProgress = 0\r\n  \r\n  // 递归枚举所有可能的抽卡组合\r\n  function recurse(index: number, counts: number[], remaining: number) {\r\n    if (index === cardCounts.length) {\r\n      if (remaining !== 0) return\r\n      \r\n      // 计算这种组合的数量\r\n      let prob = 1n\r\n      for (let i = 0; i < counts.length; i++) {\r\n        const cardCount = cardCounts[i]\r\n        const drawCount = counts[i]\r\n        if (cardCount === undefined || drawCount === undefined) continue\r\n        prob *= combination(cardCount, drawCount)\r\n      }\r\n      \r\n      total += prob\r\n      if (conditionFunc(counts)) {\r\n        valid += prob\r\n      }\r\n      return\r\n    }\r\n\r\n    // 报告进度\r\n    const progress = Math.min(100, Math.floor((index / cardCounts.length) * 100))\r\n    if (progress > lastReportedProgress && onProgress) {\r\n      lastReportedProgress = progress\r\n      onProgress(progress, `精确计算中: ${progress}%`)\r\n    }\r\n\r\n    // 尝试从当前卡牌类型抽取 k 张\r\n    const currentCount = cardCounts[index]\r\n    if (currentCount === undefined) return\r\n    \r\n    const max = Math.min(currentCount, remaining)\r\n    for (let k = 0; k <= max; k++) {\r\n      counts[index] = k\r\n      recurse(index + 1, [...counts], remaining - k)\r\n    }\r\n  }\r\n  \r\n  recurse(0, [], draws)\r\n  \r\n  if (onProgress) {\r\n    onProgress(100, '精确计算完成')\r\n  }\r\n  \r\n  return {\r\n    valid,\r\n    total,\r\n    probability: Number((valid * 10000n) / total) / 100,\r\n    calculationMethod: '精确计算'\r\n  }\r\n}\r\n\r\n/**\r\n * 蒙特卡洛模拟计算概率\r\n * @param cardCounts 各种卡牌的数量数组\r\n * @param draws 抽取的卡牌数\r\n * @param condition 条件表达式字符串或条件函数\r\n * @param simulations 模拟次数（默认100000）\r\n * @param onProgress 进度回调\r\n */\r\nexport function calculateMonteCarlo(\r\n  cardCounts: number[],\r\n  draws: number,\r\n  condition: string | ConditionFunction,\r\n  simulations: number = 100000,\r\n  onProgress?: ProgressCallback\r\n): CalculationResult {\r\n  const deck = createDeck(cardCounts)\r\n  \r\n  if (deck.length === 0) {\r\n    throw new Error('卡组为空')\r\n  }\r\n  \r\n  if (draws > deck.length) {\r\n    throw new Error(`抽取数量(${draws})不能大于卡组总数(${deck.length})`)\r\n  }\r\n  \r\n  // 编译条件\r\n  const conditionFunc = typeof condition === 'string' \r\n    ? compileConditionString(condition)\r\n    : condition\r\n  \r\n  let valid = 0\r\n  let lastReportedProgress = 0\r\n  \r\n  for (let i = 0; i < simulations; i++) {\r\n    const shuffled = shuffleArray(deck)\r\n    const counts = drawCards(shuffled, draws, cardCounts.length)\r\n    \r\n    try {\r\n      if (conditionFunc(counts)) {\r\n        valid++\r\n      }\r\n    } catch (e) {\r\n      // 忽略条件执行错误\r\n    }\r\n    \r\n    // 报告进度\r\n    const progress = Math.floor(((i + 1) / simulations) * 100)\r\n    if (progress > lastReportedProgress && onProgress) {\r\n      lastReportedProgress = progress\r\n      onProgress(progress, `蒙特卡洛模拟: ${progress}%`)\r\n    }\r\n  }\r\n  \r\n  if (onProgress) {\r\n    onProgress(100, '蒙特卡洛模拟完成')\r\n  }\r\n  \r\n  return {\r\n    valid,\r\n    total: simulations,\r\n    probability: (valid / simulations) * 100,\r\n    calculationMethod: '蒙特卡洛模拟'\r\n  }\r\n}\r\n\r\n/**\r\n * 快速蒙特卡洛计算（已编译的条件函数）\r\n * 主要用于优化器中大量重复计算\r\n */\r\nexport function quickMonteCarlo(\r\n  cardCounts: number[],\r\n  draws: number,\r\n  conditionFunc: ConditionFunction,\r\n  simulations: number\r\n): number {\r\n  const deck = createDeck(cardCounts)\r\n  \r\n  if (deck.length === 0 || deck.length < draws) {\r\n    return 0\r\n  }\r\n  \r\n  let valid = 0\r\n  \r\n  for (let i = 0; i < simulations; i++) {\r\n    const shuffled = shuffleArray(deck)\r\n    const counts = drawCards(shuffled, draws, cardCounts.length)\r\n    \r\n    try {\r\n      if (conditionFunc(counts)) {\r\n        valid++\r\n      }\r\n    } catch (e) {\r\n      // 忽略条件执行错误\r\n    }\r\n  }\r\n  \r\n  return (valid / simulations) * 100\r\n}\r\n\r\n/**\r\n * 自动选择计算方法\r\n * 根据问题规模自动选择精确计算或蒙特卡洛模拟\r\n */\r\nexport function calculateAuto(\r\n  cardCounts: number[],\r\n  draws: number,\r\n  condition: string,\r\n  onProgress?: ProgressCallback\r\n): CalculationResult {\r\n  const totalCards = cardCounts.reduce((a, b) => a + b, 0)\r\n  const nonZeroTypes = cardCounts.filter(c => c > 0).length\r\n  \r\n  // 估算计算复杂度\r\n  // 如果卡组较小且卡牌类型较少，使用精确计算\r\n  // 否则使用蒙特卡洛模拟\r\n  const useExact = totalCards <= 40 && nonZeroTypes <= 10 && draws <= 6\r\n  \r\n  if (useExact) {\r\n    return calculateExact(cardCounts, draws, condition, onProgress)\r\n  } else {\r\n    // 根据复杂度调整模拟次数\r\n    const simulations = totalCards <= 60 ? 100000 : 500000\r\n    return calculateMonteCarlo(cardCounts, draws, condition, simulations, onProgress)\r\n  }\r\n}\r\n\r\n","/**\r\n * 卡组优化器模块\r\n */\r\n\r\nimport type { Card, OptimizationResult, OptimizationOptions, OptimizationPlan } from './types'\r\nimport { quickMonteCarlo } from './calculator'\r\nimport { compileConditionString, parseConditionVariables } from './condition'\r\n\r\n/**\r\n * 生成卡组优化方案\r\n * @param cards 卡牌列表\r\n * @param condition 条件表达式\r\n * @param draws 抽卡数\r\n * @param targetRate 目标启动率（0-100）\r\n * @param options 优化选项\r\n */\r\nexport function optimize(\r\n  cards: Card[],\r\n  condition: string,\r\n  draws: number,\r\n  targetRate: number,\r\n  options: OptimizationOptions = {}\r\n): OptimizationResult {\r\n  const { simulations = 30000, onProgress } = options\r\n  \r\n  // 获取当前卡组数据\r\n  const currentCounts = cards.map(c => c.count)\r\n  const totalCards = currentCounts.reduce((a, b) => a + b, 0)\r\n\r\n  if (totalCards === 0) {\r\n    throw new Error('卡组为空，请先添加卡牌')\r\n  }\r\n\r\n  if (!condition || condition.trim() === '') {\r\n    throw new Error('请先设置展开条件')\r\n  }\r\n\r\n  // 编译条件函数\r\n  onProgress?.(5, '编译条件表达式...')\r\n  const conditionFunc = compileConditionString(condition)\r\n\r\n  // 计算当前概率\r\n  onProgress?.(10, '计算当前启动率...')\r\n  const currentRate = quickMonteCarlo(currentCounts, draws, conditionFunc, simulations)\r\n  \r\n  // 自动判断优化方向：当前概率 < 目标概率时提高，否则降低\r\n  const direction = currentRate < targetRate ? 'increase' : 'decrease'\r\n  \r\n  onProgress?.(15, `分析卡组结构（${direction === 'increase' ? '提高' : '降低'}模式）...`)\r\n\r\n  // 解析条件中使用的卡牌\r\n  const conditionVars = parseConditionVariables(condition)\r\n  \r\n  // 找出关键卡和非关键卡\r\n  interface CardInfo {\r\n    index: number\r\n    card: Card\r\n    isKey: boolean\r\n  }\r\n  \r\n  const keyCards: CardInfo[] = []\r\n  const nonKeyCards: CardInfo[] = []\r\n  \r\n  cards.forEach((card, index) => {\r\n    if (!card) return\r\n    if (card.count > 0) {\r\n      if (conditionVars.includes(index)) {\r\n        keyCards.push({ index, card, isKey: true })\r\n      } else {\r\n        nonKeyCards.push({ index, card, isKey: false })\r\n      }\r\n    }\r\n  })\r\n\r\n  onProgress?.(20, '生成调整方案...')\r\n\r\n  // 生成调整方案\r\n  const plans: OptimizationPlan[] = []\r\n\r\n  if (direction === 'increase') {\r\n    // ===== 提高启动率的方案 =====\r\n    generateIncreasePlans(plans, keyCards, nonKeyCards, currentCounts, totalCards)\r\n  } else {\r\n    // ===== 降低启动率的方案 =====\r\n    generateDecreasePlans(plans, keyCards, nonKeyCards, currentCounts, totalCards)\r\n  }\r\n\r\n  onProgress?.(30, `评估方案效果 (0/${plans.length})...`)\r\n\r\n  // 计算每个方案的概率\r\n  const totalPlans = plans.length\r\n  for (let i = 0; i < totalPlans; i++) {\r\n    const plan = plans[i]\r\n    if (!plan) continue\r\n    \r\n    const newTotal = plan.newCounts.reduce((a, b) => a + b, 0)\r\n    const actualDraws = Math.min(draws, newTotal)\r\n    plan.newRate = quickMonteCarlo(plan.newCounts, actualDraws, conditionFunc, Math.floor(simulations / 2))\r\n    plan.improvement = plan.newRate - currentRate\r\n    \r\n    // 根据优化方向判断是否达标\r\n    plan.reachTarget = direction === 'increase' \r\n      ? plan.newRate >= targetRate\r\n      : plan.newRate <= targetRate\r\n\r\n    // 每处理5个方案汇报一次进度\r\n    if (i % 5 === 0 || i === totalPlans - 1) {\r\n      const progress = 30 + Math.floor(((i + 1) / totalPlans) * 65)\r\n      onProgress?.(progress, `评估方案效果 (${i + 1}/${totalPlans})...`)\r\n    }\r\n  }\r\n\r\n  onProgress?.(95, '整理结果...')\r\n\r\n  // 根据优化方向过滤方案\r\n  const validPlans = plans.filter(p => \r\n    direction === 'increase' ? p.improvement > 0.1 : p.improvement < -0.1\r\n  )\r\n\r\n  // 按类型分组\r\n  const keepDeckPlans = validPlans.filter(p => \r\n    direction === 'increase' \r\n      ? (p.type === 'increase_key' || p.type === 'increase_multi_key')\r\n      : (p.type === 'decrease_key' || p.type === 'decrease_multi_key')\r\n  )\r\n  const expandDeckPlans = validPlans.filter(p => p.type === 'expand_deck')\r\n  const reduceDeckPlans = validPlans.filter(p => p.type === 'reduce_deck')\r\n\r\n  // 排序函数：最接近目标的在前，达到目标的优先\r\n  const sortPlans = (arr: OptimizationPlan[]) => {\r\n    return arr.sort((a, b) => {\r\n      // 达到目标的优先\r\n      if (a.reachTarget !== b.reachTarget) {\r\n        return a.reachTarget ? -1 : 1\r\n      }\r\n      // 越接近目标越靠前（差距小的在前）\r\n      const diffA = Math.abs(targetRate - a.newRate)\r\n      const diffB = Math.abs(targetRate - b.newRate)\r\n      return diffA - diffB\r\n    })\r\n  }\r\n\r\n  // 对每组方案排序\r\n  sortPlans(keepDeckPlans)\r\n  sortPlans(expandDeckPlans)\r\n  sortPlans(reduceDeckPlans)\r\n\r\n  // 标记每组的最佳方案\r\n  if (keepDeckPlans.length > 0 && keepDeckPlans[0]) keepDeckPlans[0].isBest = true\r\n  if (expandDeckPlans.length > 0 && expandDeckPlans[0]) expandDeckPlans[0].isBest = true\r\n  if (reduceDeckPlans.length > 0 && reduceDeckPlans[0]) reduceDeckPlans[0].isBest = true\r\n\r\n  // 限制每组数量\r\n  const maxPerGroup = 10\r\n\r\n  onProgress?.(100, '完成！')\r\n\r\n  return {\r\n    currentRate,\r\n    targetRate,\r\n    direction,\r\n    keepDeckPlans: keepDeckPlans.slice(0, maxPerGroup),\r\n    expandDeckPlans: expandDeckPlans.slice(0, maxPerGroup),\r\n    reduceDeckPlans: reduceDeckPlans.slice(0, maxPerGroup),\r\n    totalPlansCount: validPlans.length\r\n  }\r\n}\r\n\r\n/**\r\n * 生成提高启动率的方案\r\n */\r\nfunction generateIncreasePlans(\r\n  plans: OptimizationPlan[],\r\n  keyCards: Array<{ index: number; card: Card; isKey: boolean }>,\r\n  nonKeyCards: Array<{ index: number; card: Card; isKey: boolean }>,\r\n  currentCounts: number[],\r\n  totalCards: number\r\n) {\r\n  // 方案类型1：增加关键卡数量\r\n  for (const keyCard of keyCards) {\r\n    if (!keyCard) continue\r\n    const keyMaxCount = keyCard.card.maxCount ?? 3\r\n    if (keyCard.card.count < keyMaxCount) {\r\n      const maxAdd = keyMaxCount - keyCard.card.count\r\n      for (let add = 1; add <= maxAdd; add++) {\r\n        for (const nonKey of nonKeyCards) {\r\n          if (!nonKey) continue\r\n          if (nonKey.card.count >= add) {\r\n            const newCounts = [...currentCounts]\r\n            const keyIdx = keyCard.index\r\n            const nonKeyIdx = nonKey.index\r\n            if (newCounts[keyIdx] !== undefined) newCounts[keyIdx] += add\r\n            if (newCounts[nonKeyIdx] !== undefined) newCounts[nonKeyIdx] -= add\r\n\r\n            plans.push({\r\n              type: 'increase_key',\r\n              description: `增加「${keyCard.card.name || keyCard.card.label}」${add}张，减少「${nonKey.card.name || nonKey.card.label}」${add}张`,\r\n              changes: [\r\n                { card: keyCard.card, change: +add },\r\n                { card: nonKey.card, change: -add }\r\n              ],\r\n              newCounts,\r\n              newRate: 0,\r\n              improvement: 0,\r\n              reachTarget: false,\r\n              priority: 1\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 方案类型2：多个关键卡同时增加\r\n  if (keyCards.length >= 2) {\r\n    for (let i = 0; i < keyCards.length; i++) {\r\n      for (let j = i + 1; j < keyCards.length; j++) {\r\n        const card1 = keyCards[i]\r\n        const card2 = keyCards[j]\r\n        if (!card1 || !card2) continue\r\n        \r\n        const card1MaxCount = card1.card.maxCount ?? 3\r\n        const card2MaxCount = card2.card.maxCount ?? 3\r\n        if (card1.card.count < card1MaxCount && card2.card.count < card2MaxCount) {\r\n          const totalReduce = 2\r\n          for (const nonKey of nonKeyCards) {\r\n            if (!nonKey) continue\r\n            if (nonKey.card.count >= totalReduce) {\r\n              const newCounts = [...currentCounts]\r\n              const idx1 = card1.index\r\n              const idx2 = card2.index\r\n              const idxNonKey = nonKey.index\r\n              if (newCounts[idx1] !== undefined) newCounts[idx1] += 1\r\n              if (newCounts[idx2] !== undefined) newCounts[idx2] += 1\r\n              if (newCounts[idxNonKey] !== undefined) newCounts[idxNonKey] -= totalReduce\r\n\r\n              plans.push({\r\n                type: 'increase_multi_key',\r\n                description: `增加「${card1.card.name || card1.card.label}」1张 + 「${card2.card.name || card2.card.label}」1张，减少「${nonKey.card.name || nonKey.card.label}」2张`,\r\n                changes: [\r\n                  { card: card1.card, change: +1 },\r\n                  { card: card2.card, change: +1 },\r\n                  { card: nonKey.card, change: -2 }\r\n                ],\r\n                newCounts,\r\n                newRate: 0,\r\n                improvement: 0,\r\n                reachTarget: false,\r\n                priority: 2\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 方案类型3：扩充卡组（不超过60张上限）\r\n  if (totalCards < 60) {\r\n    for (const keyCard of keyCards) {\r\n      if (!keyCard) continue\r\n      const keyMaxCount = keyCard.card.maxCount ?? 3\r\n      if (keyCard.card.count < keyMaxCount) {\r\n        const maxByCard = keyMaxCount - keyCard.card.count\r\n        const maxByDeck = 60 - totalCards\r\n        const maxAdd = Math.min(maxByCard, maxByDeck, 2)\r\n        \r\n        if (maxAdd > 0) {\r\n          for (let add = 1; add <= maxAdd; add++) {\r\n            const newCounts = [...currentCounts]\r\n            const idx = keyCard.index\r\n            if (newCounts[idx] !== undefined) newCounts[idx] += add\r\n\r\n            plans.push({\r\n              type: 'expand_deck',\r\n              description: `增加「${keyCard.card.name || keyCard.card.label}」${add}张（卡组从${totalCards}张变为${totalCards + add}张）`,\r\n              changes: [{ card: keyCard.card, change: +add }],\r\n              newCounts,\r\n              newDeckSize: totalCards + add,\r\n              newRate: 0,\r\n              improvement: 0,\r\n              reachTarget: false,\r\n              priority: 3\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 方案类型4：减少非关键卡\r\n  for (const nonKey of nonKeyCards) {\r\n    if (!nonKey) continue\r\n    if (nonKey.card.count >= 1 && totalCards > 40) {\r\n      const maxReduce = Math.min(nonKey.card.count, totalCards - 40, 3)\r\n      \r\n      for (let reduce = 1; reduce <= maxReduce; reduce++) {\r\n        const newCounts = [...currentCounts]\r\n        const idx = nonKey.index\r\n        if (newCounts[idx] !== undefined) newCounts[idx] -= reduce\r\n\r\n        plans.push({\r\n          type: 'reduce_deck',\r\n          description: `减少「${nonKey.card.name || nonKey.card.label}」${reduce}张（卡组从${totalCards}张变为${totalCards - reduce}张）`,\r\n          changes: [{ card: nonKey.card, change: -reduce }],\r\n          newCounts,\r\n          newDeckSize: totalCards - reduce,\r\n          newRate: 0,\r\n          improvement: 0,\r\n          reachTarget: false,\r\n          priority: 4\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 生成降低启动率的方案\r\n */\r\nfunction generateDecreasePlans(\r\n  plans: OptimizationPlan[],\r\n  keyCards: Array<{ index: number; card: Card; isKey: boolean }>,\r\n  nonKeyCards: Array<{ index: number; card: Card; isKey: boolean }>,\r\n  currentCounts: number[],\r\n  totalCards: number\r\n) {\r\n  // 方案类型1：减少关键卡数量（用非关键卡替换）\r\n  for (const keyCard of keyCards) {\r\n    if (!keyCard) continue\r\n    if (keyCard.card.count >= 1) {\r\n      const maxReduce = keyCard.card.count\r\n      for (let reduce = 1; reduce <= Math.min(maxReduce, 3); reduce++) {\r\n        for (const nonKey of nonKeyCards) {\r\n          if (!nonKey) continue\r\n          const nonKeyMaxCount = nonKey.card.maxCount ?? 3\r\n          if (nonKey.card.count < nonKeyMaxCount) {\r\n            // 检查增加后不超过上限\r\n            const canAdd = Math.min(reduce, nonKeyMaxCount - nonKey.card.count)\r\n            if (canAdd >= reduce) {\r\n              const newCounts = [...currentCounts]\r\n              const keyIdx = keyCard.index\r\n              const nonKeyIdx = nonKey.index\r\n              if (newCounts[keyIdx] !== undefined) newCounts[keyIdx] -= reduce\r\n              if (newCounts[nonKeyIdx] !== undefined) newCounts[nonKeyIdx] += reduce\r\n\r\n              plans.push({\r\n                type: 'decrease_key',\r\n                description: `减少「${keyCard.card.name || keyCard.card.label}」${reduce}张，增加「${nonKey.card.name || nonKey.card.label}」${reduce}张`,\r\n                changes: [\r\n                  { card: keyCard.card, change: -reduce },\r\n                  { card: nonKey.card, change: +reduce }\r\n                ],\r\n                newCounts,\r\n                newRate: 0,\r\n                improvement: 0,\r\n                reachTarget: false,\r\n                priority: 1\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 方案类型2：多个关键卡同时减少\r\n  if (keyCards.length >= 2) {\r\n    for (let i = 0; i < keyCards.length; i++) {\r\n      for (let j = i + 1; j < keyCards.length; j++) {\r\n        const card1 = keyCards[i]\r\n        const card2 = keyCards[j]\r\n        if (!card1 || !card2) continue\r\n        if (card1.card.count >= 1 && card2.card.count >= 1) {\r\n          for (const nonKey of nonKeyCards) {\r\n            if (!nonKey) continue\r\n            const nonKeyMaxCount = nonKey.card.maxCount ?? 3\r\n            // 需要能增加2张\r\n            if (nonKey.card.count + 2 <= nonKeyMaxCount) {\r\n              const newCounts = [...currentCounts]\r\n              const idx1 = card1.index\r\n              const idx2 = card2.index\r\n              const idxNonKey = nonKey.index\r\n              if (newCounts[idx1] !== undefined) newCounts[idx1] -= 1\r\n              if (newCounts[idx2] !== undefined) newCounts[idx2] -= 1\r\n              if (newCounts[idxNonKey] !== undefined) newCounts[idxNonKey] += 2\r\n\r\n              plans.push({\r\n                type: 'decrease_multi_key',\r\n                description: `减少「${card1.card.name || card1.card.label}」1张 + 「${card2.card.name || card2.card.label}」1张，增加「${nonKey.card.name || nonKey.card.label}」2张`,\r\n                changes: [\r\n                  { card: card1.card, change: -1 },\r\n                  { card: card2.card, change: -1 },\r\n                  { card: nonKey.card, change: +2 }\r\n                ],\r\n                newCounts,\r\n                newRate: 0,\r\n                improvement: 0,\r\n                reachTarget: false,\r\n                priority: 2\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 方案类型3：扩充卡组（增加非关键卡，稀释关键卡比例）\r\n  if (totalCards < 60) {\r\n    for (const nonKey of nonKeyCards) {\r\n      if (!nonKey) continue\r\n      const nonKeyMaxCount = nonKey.card.maxCount ?? 3\r\n      if (nonKey.card.count < nonKeyMaxCount) {\r\n        const maxByCard = nonKeyMaxCount - nonKey.card.count\r\n        const maxByDeck = 60 - totalCards\r\n        const maxAdd = Math.min(maxByCard, maxByDeck, 3)\r\n        \r\n        if (maxAdd > 0) {\r\n          for (let add = 1; add <= maxAdd; add++) {\r\n            const newCounts = [...currentCounts]\r\n            const idx = nonKey.index\r\n            if (newCounts[idx] !== undefined) newCounts[idx] += add\r\n\r\n            plans.push({\r\n              type: 'expand_deck',\r\n              description: `增加「${nonKey.card.name || nonKey.card.label}」${add}张（卡组从${totalCards}张变为${totalCards + add}张）`,\r\n              changes: [{ card: nonKey.card, change: +add }],\r\n              newCounts,\r\n              newDeckSize: totalCards + add,\r\n              newRate: 0,\r\n              improvement: 0,\r\n              reachTarget: false,\r\n              priority: 3\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 方案类型4：减少关键卡（直接移除，减少卡组总数）\r\n  for (const keyCard of keyCards) {\r\n    if (!keyCard) continue\r\n    if (keyCard.card.count >= 1 && totalCards > 40) {\r\n      const maxReduce = Math.min(keyCard.card.count, totalCards - 40, 3)\r\n      \r\n      for (let reduce = 1; reduce <= maxReduce; reduce++) {\r\n        const newCounts = [...currentCounts]\r\n        const idx = keyCard.index\r\n        if (newCounts[idx] !== undefined) newCounts[idx] -= reduce\r\n\r\n        plans.push({\r\n          type: 'reduce_deck',\r\n          description: `减少「${keyCard.card.name || keyCard.card.label}」${reduce}张（卡组从${totalCards}张变为${totalCards - reduce}张）`,\r\n          changes: [{ card: keyCard.card, change: -reduce }],\r\n          newCounts,\r\n          newDeckSize: totalCards - reduce,\r\n          newRate: 0,\r\n          improvement: 0,\r\n          reachTarget: false,\r\n          priority: 4\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 应用优化方案到卡组\r\n */\r\nexport function applyPlan(plan: OptimizationPlan, cards: Card[]): void {\r\n  plan.changes.forEach(change => {\r\n    // 优先使用 label 匹配（label 是唯一的），其次使用 name 匹配（需要非空）\r\n    const cardIndex = cards.findIndex(c => {\r\n      if (change.card.label && c.label === change.card.label) {\r\n        return true\r\n      }\r\n      if (change.card.name && c.name && c.name === change.card.name) {\r\n        return true\r\n      }\r\n      return false\r\n    })\r\n    \r\n    if (cardIndex !== -1) {\r\n      const card = cards[cardIndex]\r\n      if (card) {\r\n        card.count = Math.max(0, card.count + change.change)\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\n","/**\r\n * Web Worker 代码生成模块\r\n * 生成可在浏览器 Worker 中运行的独立代码\r\n */\r\n\r\n/**\r\n * 生成精确计算 Worker 代码\r\n */\r\nexport function generateExactWorkerCode(): string {\r\n  return `\r\n// 组合数缓存\r\nconst combinationCache = new Map();\r\n\r\nfunction combination(n, k) {\r\n  if (k < 0 || k > n) return 0n;\r\n  if (k === 0n || k === n) return 1n;\r\n  \r\n  const key = \\`\\${n},\\${k}\\`;\r\n  if (combinationCache.has(key)) return combinationCache.get(key);\r\n  \r\n  let result = 1n;\r\n  for (let i = 1n; i <= BigInt(k); i++) {\r\n    result = result * (BigInt(n) - BigInt(k) + i) / i;\r\n  }\r\n  \r\n  combinationCache.set(key, result);\r\n  return result;\r\n}\r\n\r\nfunction varToIndex(varName) {\r\n  const lc = varName.toLowerCase();\r\n  if (lc.length === 1) {\r\n    const code = lc.charCodeAt(0) - 97;\r\n    if (code >= 0 && code < 26) return code;\r\n  }\r\n  if (lc.length === 2 && lc[0] === 'a') {\r\n    const code = lc.charCodeAt(1) - 97;\r\n    if (code >= 0 && code < 4) return 26 + code;\r\n  }\r\n  throw new Error(\\`无效的卡名称: \\${varName}\\`);\r\n}\r\n\r\nfunction calculateProbability(cardCounts, draws, condition) {\r\n  const totalCards = cardCounts.reduce((a, b) => a + b, 0);\r\n  let valid = 0n, total = 0n;\r\n  let lastReportedProgress = 0;\r\n\r\n  const conditionFunc = new Function('counts', \\`return \\${condition.replace(/([a-zA-Z]+)/g, (m) => \\`counts[\\${varToIndex(m)}]\\`)}\\`);\r\n\r\n  function recurse(index, counts, remaining) {\r\n    if (index === cardCounts.length) {\r\n      if (remaining !== 0) return;\r\n      \r\n      let prob = 1n;\r\n      for (let i = 0; i < counts.length; i++) {\r\n        prob *= combination(cardCounts[i], counts[i]);\r\n      }\r\n      \r\n      total += prob;\r\n      if (conditionFunc(counts)) valid += prob;\r\n      return;\r\n    }\r\n\r\n    const progress = Math.min(100, Math.floor((index / cardCounts.length) * 100));\r\n    if (progress > lastReportedProgress) {\r\n      lastReportedProgress = progress;\r\n      postMessage({ type: 'progress', progress });\r\n    }\r\n\r\n    const max = Math.min(cardCounts[index], remaining);\r\n    for (let k = 0; k <= max; k++) {\r\n      counts[index] = k;\r\n      recurse(index + 1, [...counts], remaining - k);\r\n    }\r\n  }\r\n\r\n  recurse(0, [], draws);\r\n  return { valid, total };\r\n}\r\n\r\nonmessage = function(e) {\r\n  const { cardCounts, draws, condition } = e.data;\r\n  try {\r\n    const result = calculateProbability(cardCounts, draws, condition);\r\n    postMessage({ type: 'result', valid: result.valid.toString(), total: result.total.toString(), calculationMethod: '精确计算' });\r\n  } catch (error) {\r\n    postMessage({ type: 'error', message: error.message });\r\n  }\r\n};\r\n  `.trim()\r\n}\r\n\r\n/**\r\n * 生成蒙特卡洛模拟 Worker 代码\r\n */\r\nexport function generateMonteCarloWorkerCode(): string {\r\n  return `\r\nfunction varToIndex(varName) {\r\n  const lc = varName.toLowerCase();\r\n  if (lc.length === 1) {\r\n    const code = lc.charCodeAt(0) - 97;\r\n    if (code >= 0 && code < 26) return code;\r\n  }\r\n  if (lc.length === 2 && lc[0] === 'a') {\r\n    const code = lc.charCodeAt(1) - 97;\r\n    if (code >= 0 && code < 4) return 26 + code;\r\n  }\r\n  throw new Error(\"无效的卡名称: \" + varName);\r\n}\r\n\r\nfunction drawCards(shuffledDeck, draws, cardTypeCount) {\r\n  let counts = Array(cardTypeCount).fill(0);\r\n  const drawn = shuffledDeck.slice(0, draws);\r\n  drawn.forEach(idx => { counts[idx]++; });\r\n  return counts;\r\n}\r\n\r\nfunction shuffleArray(arr) {\r\n  let array = arr.slice();\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    let j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n}\r\n\r\nonmessage = function(e) {\r\n  try {\r\n    const { cardCounts, draws, condition, simulations = 100000 } = e.data;\r\n    \r\n    let deck = [];\r\n    for (let i = 0; i < cardCounts.length; i++) {\r\n      for (let j = 0; j < cardCounts[i]; j++) {\r\n        deck.push(i);\r\n      }\r\n    }\r\n    \r\n    if (deck.length === 0) {\r\n      postMessage({ type: 'result', valid: 0, total: simulations, calculationMethod: \"蒙特卡洛模拟\" });\r\n      return;\r\n    }\r\n\r\n    const replacedCondition = condition.replace(/([a-zA-Z]+)/g, function(m) {\r\n      return \"counts[\" + varToIndex(m) + \"]\";\r\n    });\r\n    const conditionFunc = new Function(\"counts\", \"return \" + replacedCondition);\r\n    \r\n    let valid = 0;\r\n    let iter = 0;\r\n    let lastReported = 0;\r\n\r\n    function runChunk() {\r\n      const chunkSize = 5000;\r\n      for (let i = 0; i < chunkSize && iter < simulations; i++, iter++) {\r\n        const shuffled = shuffleArray(deck);\r\n        const result = drawCards(shuffled, draws, cardCounts.length);\r\n        try {\r\n          if (conditionFunc(result)) valid++;\r\n        } catch (e) {\r\n          // 忽略条件执行错误\r\n        }\r\n      }\r\n      \r\n      const progress = Math.floor((iter / simulations) * 100);\r\n      if (progress > lastReported) {\r\n        lastReported = progress;\r\n        postMessage({ type: 'progress', progress });\r\n      }\r\n      \r\n      if (iter < simulations) {\r\n        setTimeout(runChunk, 0);\r\n      } else {\r\n        postMessage({ type: 'result', valid, total: simulations, calculationMethod: \"蒙特卡洛模拟\" });\r\n      }\r\n    }\r\n    \r\n    runChunk();\r\n  } catch (error) {\r\n    postMessage({ type: 'error', message: error.message });\r\n  }\r\n};\r\n  `.trim()\r\n}\r\n\r\n/**\r\n * 生成优化器 Worker 代码\r\n */\r\nexport function generateOptimizerWorkerCode(): string {\r\n  return `\r\n// 变量名转索引\r\nfunction varToIndex(varName) {\r\n  const lc = varName.toLowerCase();\r\n  if (lc.length === 1) {\r\n    const code = lc.charCodeAt(0) - 97;\r\n    if (code >= 0 && code < 26) return code;\r\n  }\r\n  if (lc.length === 2 && lc[0] === 'a') {\r\n    const code = lc.charCodeAt(1) - 97;\r\n    if (code >= 0 && code < 4) return 26 + code;\r\n  }\r\n  throw new Error('无效的卡名称: ' + varName);\r\n}\r\n\r\n// 洗牌\r\nfunction shuffleArray(arr) {\r\n  const array = arr.slice();\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n}\r\n\r\n// 抽卡并统计\r\nfunction drawCards(shuffledDeck, draws, cardTypeCount) {\r\n  const counts = Array(cardTypeCount).fill(0);\r\n  const drawn = shuffledDeck.slice(0, draws);\r\n  drawn.forEach((idx) => {\r\n    counts[idx]++;\r\n  });\r\n  return counts;\r\n}\r\n\r\n// 快速蒙特卡洛计算\r\nfunction quickMonteCarlo(cardCounts, draws, conditionFunc, simulations) {\r\n  let deck = [];\r\n  for (let i = 0; i < cardCounts.length; i++) {\r\n    for (let j = 0; j < cardCounts[i]; j++) {\r\n      deck.push(i);\r\n    }\r\n  }\r\n\r\n  if (deck.length === 0 || deck.length < draws) {\r\n    return 0;\r\n  }\r\n\r\n  let valid = 0;\r\n  for (let i = 0; i < simulations; i++) {\r\n    const shuffled = shuffleArray(deck);\r\n    const counts = drawCards(shuffled, draws, cardCounts.length);\r\n    try {\r\n      if (conditionFunc(counts)) valid++;\r\n    } catch (e) {\r\n      // 忽略条件执行错误\r\n    }\r\n  }\r\n\r\n  return (valid / simulations) * 100;\r\n}\r\n\r\n// 解析条件中使用的变量\r\nfunction parseConditionVariables(condition) {\r\n  const varRegex = /([a-zA-Z]+)/g;\r\n  const variables = new Set();\r\n  let match;\r\n  while ((match = varRegex.exec(condition)) !== null) {\r\n    try {\r\n      const idx = varToIndex(match[1]);\r\n      variables.add(idx);\r\n    } catch {\r\n      // 忽略无效变量\r\n    }\r\n  }\r\n  return Array.from(variables);\r\n}\r\n\r\n// 主处理函数\r\nonmessage = function(e) {\r\n  const { cardsData, condition, draws, targetRate, simulations } = e.data;\r\n  \r\n  try {\r\n    const currentCounts = cardsData.map(c => c.count);\r\n    const totalCards = currentCounts.reduce((a, b) => a + b, 0);\r\n\r\n    // 构建条件函数\r\n    const replacedCondition = condition.replace(/([a-zA-Z]+)/g, (m) => {\r\n      return 'counts[' + varToIndex(m) + ']';\r\n    });\r\n    const conditionFunc = new Function('counts', 'return ' + replacedCondition);\r\n\r\n    postMessage({ type: 'progress', progress: 5, text: '计算当前启动率...' });\r\n\r\n    // 计算当前概率\r\n    const currentRate = quickMonteCarlo(currentCounts, draws, conditionFunc, simulations);\r\n    \r\n    // 自动判断优化方向：当前概率 < 目标概率时提高，否则降低\r\n    const direction = currentRate < targetRate ? 'increase' : 'decrease';\r\n    \r\n    postMessage({ type: 'progress', progress: 15, text: '分析卡组结构（' + (direction === 'increase' ? '提高' : '降低') + '模式）...' });\r\n\r\n    // 解析条件中使用的卡牌\r\n    const conditionVars = parseConditionVariables(condition);\r\n    \r\n    // 找出关键卡和非关键卡\r\n    const keyCards = [];\r\n    const nonKeyCards = [];\r\n    \r\n    cardsData.forEach((card, index) => {\r\n      if (card.count > 0) {\r\n        if (conditionVars.includes(index)) {\r\n          keyCards.push({ index, card, isKey: true });\r\n        } else {\r\n          nonKeyCards.push({ index, card, isKey: false });\r\n        }\r\n      }\r\n    });\r\n\r\n    postMessage({ type: 'progress', progress: 20, text: '生成调整方案...' });\r\n\r\n    // 生成调整方案\r\n    const plans = [];\r\n\r\n    if (direction === 'increase') {\r\n      // === 提高启动率的方案 ===\r\n      \r\n      // 方案1：增加关键卡数量\r\n      for (const keyCard of keyCards) {\r\n        const keyMaxCount = keyCard.card.maxCount || 3;\r\n        if (keyCard.card.count < keyMaxCount) {\r\n          const maxAdd = keyMaxCount - keyCard.card.count;\r\n          for (let add = 1; add <= maxAdd; add++) {\r\n            for (const nonKey of nonKeyCards) {\r\n              if (nonKey.card.count >= add) {\r\n                const newCounts = [...currentCounts];\r\n                newCounts[keyCard.index] += add;\r\n                newCounts[nonKey.index] -= add;\r\n                plans.push({\r\n                  type: 'increase_key',\r\n                  description: '增加「' + (keyCard.card.name || keyCard.card.label) + '」' + add + '张，减少「' + (nonKey.card.name || nonKey.card.label) + '」' + add + '张',\r\n                  changes: [\r\n                    { card: keyCard.card, change: +add },\r\n                    { card: nonKey.card, change: -add }\r\n                  ],\r\n                  newCounts,\r\n                  newRate: 0,\r\n                  improvement: 0,\r\n                  reachTarget: false,\r\n                  priority: 1\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 方案2：多个关键卡同时增加\r\n      if (keyCards.length >= 2) {\r\n        for (let i = 0; i < keyCards.length; i++) {\r\n          for (let j = i + 1; j < keyCards.length; j++) {\r\n            const card1 = keyCards[i];\r\n            const card2 = keyCards[j];\r\n            const card1MaxCount = card1.card.maxCount || 3;\r\n            const card2MaxCount = card2.card.maxCount || 3;\r\n            if (card1.card.count < card1MaxCount && card2.card.count < card2MaxCount) {\r\n              for (const nonKey of nonKeyCards) {\r\n                if (nonKey.card.count >= 2) {\r\n                  const newCounts = [...currentCounts];\r\n                  newCounts[card1.index] += 1;\r\n                  newCounts[card2.index] += 1;\r\n                  newCounts[nonKey.index] -= 2;\r\n                  plans.push({\r\n                    type: 'increase_multi_key',\r\n                    description: '增加「' + (card1.card.name || card1.card.label) + '」1张 + 「' + (card2.card.name || card2.card.label) + '」1张，减少「' + (nonKey.card.name || nonKey.card.label) + '」2张',\r\n                    changes: [\r\n                      { card: card1.card, change: +1 },\r\n                      { card: card2.card, change: +1 },\r\n                      { card: nonKey.card, change: -2 }\r\n                    ],\r\n                    newCounts,\r\n                    newRate: 0,\r\n                    improvement: 0,\r\n                    reachTarget: false,\r\n                    priority: 2\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 方案3：扩充卡组\r\n      if (totalCards < 60) {\r\n        for (const keyCard of keyCards) {\r\n          const keyMaxCount = keyCard.card.maxCount || 3;\r\n          if (keyCard.card.count < keyMaxCount) {\r\n            const maxByCard = keyMaxCount - keyCard.card.count;\r\n            const maxByDeck = 60 - totalCards;\r\n            const maxAdd = Math.min(maxByCard, maxByDeck, 2);\r\n            if (maxAdd > 0) {\r\n              for (let add = 1; add <= maxAdd; add++) {\r\n                const newCounts = [...currentCounts];\r\n                newCounts[keyCard.index] += add;\r\n                plans.push({\r\n                  type: 'expand_deck',\r\n                  description: '增加「' + (keyCard.card.name || keyCard.card.label) + '」' + add + '张（卡组从' + totalCards + '张变为' + (totalCards + add) + '张）',\r\n                  changes: [{ card: keyCard.card, change: +add }],\r\n                  newCounts,\r\n                  newDeckSize: totalCards + add,\r\n                  newRate: 0,\r\n                  improvement: 0,\r\n                  reachTarget: false,\r\n                  priority: 3\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 方案4：减少非关键卡\r\n      for (const nonKey of nonKeyCards) {\r\n        if (nonKey.card.count >= 1 && totalCards > 40) {\r\n          const maxReduce = Math.min(nonKey.card.count, totalCards - 40, 3);\r\n          for (let reduce = 1; reduce <= maxReduce; reduce++) {\r\n            const newCounts = [...currentCounts];\r\n            newCounts[nonKey.index] -= reduce;\r\n            plans.push({\r\n              type: 'reduce_deck',\r\n              description: '减少「' + (nonKey.card.name || nonKey.card.label) + '」' + reduce + '张（卡组从' + totalCards + '张变为' + (totalCards - reduce) + '张）',\r\n              changes: [{ card: nonKey.card, change: -reduce }],\r\n              newCounts,\r\n              newDeckSize: totalCards - reduce,\r\n              newRate: 0,\r\n              improvement: 0,\r\n              reachTarget: false,\r\n              priority: 4\r\n            });\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // === 降低启动率的方案 ===\r\n      \r\n      // 方案1：减少关键卡数量\r\n      for (const keyCard of keyCards) {\r\n        if (keyCard.card.count >= 1) {\r\n          const maxReduce = keyCard.card.count;\r\n          for (let reduce = 1; reduce <= Math.min(maxReduce, 3); reduce++) {\r\n            for (const nonKey of nonKeyCards) {\r\n              const nonKeyMaxCount = nonKey.card.maxCount || 3;\r\n              if (nonKey.card.count < nonKeyMaxCount) {\r\n                const canAdd = Math.min(reduce, nonKeyMaxCount - nonKey.card.count);\r\n                if (canAdd >= reduce) {\r\n                  const newCounts = [...currentCounts];\r\n                  newCounts[keyCard.index] -= reduce;\r\n                  newCounts[nonKey.index] += reduce;\r\n                  plans.push({\r\n                    type: 'decrease_key',\r\n                    description: '减少「' + (keyCard.card.name || keyCard.card.label) + '」' + reduce + '张，增加「' + (nonKey.card.name || nonKey.card.label) + '」' + reduce + '张',\r\n                    changes: [\r\n                      { card: keyCard.card, change: -reduce },\r\n                      { card: nonKey.card, change: +reduce }\r\n                    ],\r\n                    newCounts,\r\n                    newRate: 0,\r\n                    improvement: 0,\r\n                    reachTarget: false,\r\n                    priority: 1\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 方案2：多个关键卡同时减少\r\n      if (keyCards.length >= 2) {\r\n        for (let i = 0; i < keyCards.length; i++) {\r\n          for (let j = i + 1; j < keyCards.length; j++) {\r\n            const card1 = keyCards[i];\r\n            const card2 = keyCards[j];\r\n            if (card1.card.count >= 1 && card2.card.count >= 1) {\r\n              for (const nonKey of nonKeyCards) {\r\n                const nonKeyMaxCount = nonKey.card.maxCount || 3;\r\n                if (nonKey.card.count + 2 <= nonKeyMaxCount) {\r\n                  const newCounts = [...currentCounts];\r\n                  newCounts[card1.index] -= 1;\r\n                  newCounts[card2.index] -= 1;\r\n                  newCounts[nonKey.index] += 2;\r\n                  plans.push({\r\n                    type: 'decrease_multi_key',\r\n                    description: '减少「' + (card1.card.name || card1.card.label) + '」1张 + 「' + (card2.card.name || card2.card.label) + '」1张，增加「' + (nonKey.card.name || nonKey.card.label) + '」2张',\r\n                    changes: [\r\n                      { card: card1.card, change: -1 },\r\n                      { card: card2.card, change: -1 },\r\n                      { card: nonKey.card, change: +2 }\r\n                    ],\r\n                    newCounts,\r\n                    newRate: 0,\r\n                    improvement: 0,\r\n                    reachTarget: false,\r\n                    priority: 2\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 方案3：扩充卡组（稀释关键卡比例）\r\n      if (totalCards < 60) {\r\n        for (const nonKey of nonKeyCards) {\r\n          const nonKeyMaxCount = nonKey.card.maxCount || 3;\r\n          if (nonKey.card.count < nonKeyMaxCount) {\r\n            const maxByCard = nonKeyMaxCount - nonKey.card.count;\r\n            const maxByDeck = 60 - totalCards;\r\n            const maxAdd = Math.min(maxByCard, maxByDeck, 3);\r\n            if (maxAdd > 0) {\r\n              for (let add = 1; add <= maxAdd; add++) {\r\n                const newCounts = [...currentCounts];\r\n                newCounts[nonKey.index] += add;\r\n                plans.push({\r\n                  type: 'expand_deck',\r\n                  description: '增加「' + (nonKey.card.name || nonKey.card.label) + '」' + add + '张（卡组从' + totalCards + '张变为' + (totalCards + add) + '张）',\r\n                  changes: [{ card: nonKey.card, change: +add }],\r\n                  newCounts,\r\n                  newDeckSize: totalCards + add,\r\n                  newRate: 0,\r\n                  improvement: 0,\r\n                  reachTarget: false,\r\n                  priority: 3\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 方案4：减少关键卡（直接移除）\r\n      for (const keyCard of keyCards) {\r\n        if (keyCard.card.count >= 1 && totalCards > 40) {\r\n          const maxReduce = Math.min(keyCard.card.count, totalCards - 40, 3);\r\n          for (let reduce = 1; reduce <= maxReduce; reduce++) {\r\n            const newCounts = [...currentCounts];\r\n            newCounts[keyCard.index] -= reduce;\r\n            plans.push({\r\n              type: 'reduce_deck',\r\n              description: '减少「' + (keyCard.card.name || keyCard.card.label) + '」' + reduce + '张（卡组从' + totalCards + '张变为' + (totalCards - reduce) + '张）',\r\n              changes: [{ card: keyCard.card, change: -reduce }],\r\n              newCounts,\r\n              newDeckSize: totalCards - reduce,\r\n              newRate: 0,\r\n              improvement: 0,\r\n              reachTarget: false,\r\n              priority: 4\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    postMessage({ type: 'progress', progress: 30, text: '评估方案效果 (0/' + plans.length + ')...' });\r\n\r\n    // 计算每个方案的概率\r\n    const totalPlans = plans.length;\r\n    for (let i = 0; i < totalPlans; i++) {\r\n      const plan = plans[i];\r\n      const newTotal = plan.newCounts.reduce((a, b) => a + b, 0);\r\n      const actualDraws = Math.min(draws, newTotal);\r\n      plan.newRate = quickMonteCarlo(plan.newCounts, actualDraws, conditionFunc, Math.floor(simulations / 2));\r\n      plan.improvement = plan.newRate - currentRate;\r\n      plan.reachTarget = direction === 'increase' ? plan.newRate >= targetRate : plan.newRate <= targetRate;\r\n\r\n      if (i % 5 === 0 || i === totalPlans - 1) {\r\n        const progress = 30 + Math.floor(((i + 1) / totalPlans) * 65);\r\n        postMessage({ \r\n          type: 'progress', \r\n          progress, \r\n          text: '评估方案效果 (' + (i + 1) + '/' + totalPlans + ')...'\r\n        });\r\n      }\r\n    }\r\n\r\n    postMessage({ type: 'progress', progress: 95, text: '整理结果...' });\r\n\r\n    // 过滤和排序方案\r\n    const validPlans = plans.filter(p => \r\n      direction === 'increase' ? p.improvement > 0.1 : p.improvement < -0.1\r\n    );\r\n\r\n    // 按类型分组\r\n    const keepDeckPlans = validPlans.filter(p => \r\n      direction === 'increase' \r\n        ? (p.type === 'increase_key' || p.type === 'increase_multi_key')\r\n        : (p.type === 'decrease_key' || p.type === 'decrease_multi_key')\r\n    );\r\n    const expandDeckPlans = validPlans.filter(p => p.type === 'expand_deck');\r\n    const reduceDeckPlans = validPlans.filter(p => p.type === 'reduce_deck');\r\n\r\n    // 排序函数：最接近目标的在前，达到目标的优先\r\n    const sortPlans = (arr) => {\r\n      return arr.sort((a, b) => {\r\n        if (a.reachTarget !== b.reachTarget) {\r\n          return a.reachTarget ? -1 : 1;\r\n        }\r\n        const diffA = Math.abs(targetRate - a.newRate);\r\n        const diffB = Math.abs(targetRate - b.newRate);\r\n        return diffA - diffB;\r\n      });\r\n    };\r\n\r\n    // 对每组方案排序\r\n    sortPlans(keepDeckPlans);\r\n    sortPlans(expandDeckPlans);\r\n    sortPlans(reduceDeckPlans);\r\n\r\n    // 标记每组的最佳方案\r\n    if (keepDeckPlans.length > 0) keepDeckPlans[0].isBest = true;\r\n    if (expandDeckPlans.length > 0) expandDeckPlans[0].isBest = true;\r\n    if (reduceDeckPlans.length > 0) reduceDeckPlans[0].isBest = true;\r\n\r\n    // 限制每组数量\r\n    const maxPerGroup = 10;\r\n\r\n    postMessage({ type: 'progress', progress: 100, text: '完成！' });\r\n\r\n    postMessage({\r\n      type: 'result',\r\n      currentRate,\r\n      targetRate,\r\n      direction,\r\n      keepDeckPlans: keepDeckPlans.slice(0, maxPerGroup),\r\n      expandDeckPlans: expandDeckPlans.slice(0, maxPerGroup),\r\n      reduceDeckPlans: reduceDeckPlans.slice(0, maxPerGroup),\r\n      totalPlansCount: validPlans.length\r\n    });\r\n\r\n  } catch (error) {\r\n    postMessage({ type: 'error', message: error.message });\r\n  }\r\n};\r\n  `.trim()\r\n}\r\n\r\n"]}